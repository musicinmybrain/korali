#include "korali.hpp"
#include "rtnormCpp/src/rtnorm.hpp"

Korali::Distribution::TruncatedNormal::TruncatedNormal()
{
 _sigma = 1.0;
}

void Korali::Distribution::TruncatedNormal::initialize()
{
 Korali::Distribution::Base::initialize();
}

void Korali::Distribution::TruncatedNormal::finalize()
{
  Korali::Distribution::Base::finalize();
}

double Korali::Distribution::TruncatedNormal::getDensity(double x)
{
  double d = (x-_mu)/_sigma;
  return gsl_sf_exp(-0.5*d*d) / _normalization;
}

double Korali::Distribution::TruncatedNormal::getLogDensity(double x)
{
  double d = (x-_mu)/_sigma;
  return _logNormalization - 0.5*d*d;
}

double Korali::Distribution::TruncatedNormal::getRandomNumber()
{
  std::pair<double, double> s = rtnorm( _range, _minimum, _maximum, _mu, _sigma );
  return s.first;
}

void Korali::Distribution::TruncatedNormal::updateDistribution()
{
  if (_sigma <= 0.0)  Korali::logError("Incorrect Standard Deviation parameter of Truncated Normal distribution: %f.\n", _sigma);

  if (_maximum-_minimum <= 0.0)
    _aux = Korali::NaN;

  else{
    double a = (_minimum-_mu)/_sigma;
    double b = (_maximum-_mu)/_sigma;

    _normalization    = 0.5 * M_SQRT2 * M_SQRTPI * _sigma * ( gsl_sf_erf(b*M_SQRT1_2) - gsl_sf_erf(a*M_SQRT1_2) ) ;
    _logNormalization = gsl_sf_log(_normalization);
  }
}

void Korali::Distribution::TruncatedNormal::updateConditionals(const std::vector<std::string>& propertyNames, const std::vector<double>& propertyValues)
{
  // Check for conditional properties
  updateDistribution();
}
