#include "korali.hpp"
#include <numeric>
#include <limits>
#include <chrono>

#include <gsl/gsl_sort_vector.h>
#include <gsl/gsl_matrix.h>
#include <gsl/gsl_linalg.h>
#include <gsl/gsl_statistics.h>
#include <gsl/gsl_multimin.h>

Korali::Solver::MCMC::MCMC()
{
 // Initializing RNGs
 auto jsGaussian = nlohmann::json();
 jsGaussian["Type"] = "Gaussian";
 jsGaussian["Mean"] = 0.0;
 jsGaussian["Standard Deviation"] = 1.0;
 _gaussianGenerator = Korali::Distribution::Base::getDistribution(_k->_problem, jsGaussian);

 auto jsUniform = nlohmann::json();
 jsUniform["Type"] = "Uniform";
 jsUniform["Minimum"] = 0.0;
 jsUniform["Maximum"] = 1.0;
 _uniformGenerator = Korali::Distribution::Base::getDistribution(_k->_problem, jsUniform);

 _k->_consoleOutputFrequency = 500;
 _k->_resultsOutputFrequency = 500;
}

Korali::Solver::MCMC::~MCMC()
{
}

void Korali::Solver::MCMC::runGeneration()
{
 _currentRejectionCount = 0;
 while( _currentRejectionCount < _rejectionLevels )
 {
  generateCandidate(_currentRejectionCount);
  evaluateSample();
  _k->_conduit->checkProgress();
  acceptReject(_currentRejectionCount);
  _currentRejectionCount++;
 }
 _chainLength++;
 if (_chainLength > _burnIn ) updateDatabase(_chainLeader, _chainLeaderLogLikelihood);
 updateState();
}

void Korali::Solver::MCMC::initialize()
{
 N = _k->_problem->getVariableCount();

 if(_chainCovarianceScaling <= 0.0) Korali::logError("Chain Covariance Scaling must be larger 0.0 (is %lf).\n", _chainCovarianceScaling);

 if (_k->_currentGeneration > 0) return;

 // Allocating MCMC memory
 _choleskyDecompositionCovariance.resize(N*N);
 std::fill(std::begin(_choleskyDecompositionCovariance), std::end(_choleskyDecompositionCovariance), 0.0);
 _chainLeader.resize(N);
 _chainCandidate.resize(N*_rejectionLevels);
 _chainCandidatesLogPriors.resize(_rejectionLevels);
 _chainCandidatesLogLikelihoods.resize(_rejectionLevels);
 _rejectionAlphas.resize(_rejectionLevels);
 _sampleDatabase.resize(N*_maxChainLength);
 _sampleFitnessDatabase.resize(_maxChainLength);
 _chainMean.resize(N);
 _chainCovariancePlaceholder.resize(N*N);
 _chainCovariance.resize(N*N);
 _choleskyDecompositionChainCovariance.resize(N*N);
 std::fill(std::begin(_choleskyDecompositionChainCovariance), std::end(_choleskyDecompositionChainCovariance), 0.0);

 for(size_t i = 0; i < N; i++) _chainLeader[i]  = _k->_problem->getVariable(i)->_initialMean;
 for(size_t i = 0; i < N; i++) _choleskyDecompositionCovariance[i*N+i] = _k->_problem->getVariable(i)->_initialStandardDeviation;

 // Init Generation
 _acceptanceCount = 0;
 _proposedSampleCount = 0;
 _chainLength = 0;
 _currentRejectionCount = 0;
 _databaseEntryCount = 0;
 _chainLeaderLogLikelihood = std::numeric_limits<double>::lowest();
 _acceptanceRate  = 1.0;
}

void Korali::Solver::MCMC::processSample(size_t sampleId, double fitness)
{
 fitness += _chainCandidatesLogPriors[sampleId];
 if(std::isfinite(fitness) == false) 
 {
   fitness = -1.0 * std::numeric_limits<double>::max();
   Korali::logWarning(KORALI_NORMAL,"Sample %zu returned non finite fitness (fitness set to %e)!\n", sampleId, fitness);
 }
 _chainCandidatesLogLikelihoods[sampleId] = fitness;
}

void Korali::Solver::MCMC::choleskyDecomp(const std::vector<double>& inC, std::vector<double>& outL) const
{
    gsl_matrix* A = gsl_matrix_alloc(N, N);

    for(size_t d = 0; d < N; ++d)  for(size_t e = 0; e < d; ++e)
    {
        gsl_matrix_set(A,d,e,inC[d*N+e]);
        gsl_matrix_set(A,e,d,inC[e*N+d]);
    }
    for(size_t d = 0; d < N; ++d) gsl_matrix_set(A,d,d,inC[d*N+d]);

    int err = gsl_linalg_cholesky_decomp1(A);

    for(size_t d = 0; d < N; ++d)  for(size_t e = 0; e < d; ++e)
    {
        outL[d*N+e] = gsl_matrix_get(A,d,e);
    }
    for(size_t d = 0; d < N; ++d) outL[d*N+d] = gsl_matrix_get(A,d,d);

    gsl_matrix_free(A);
}

void Korali::Solver::MCMC::acceptReject(size_t trial)
{

 double denom;
 double _rejectionAlphas = recursiveAlpha(denom, _chainLeaderLogLikelihood, &_chainCandidatesLogLikelihoods[0], trial);
 if ( _rejectionAlphas == 1.0 || _rejectionAlphas > _uniformGenerator->getRandomNumber() ) {
   _acceptanceCount++;
   _chainLeaderLogLikelihood = _chainCandidatesLogLikelihoods[trial];
   for (size_t d = 0; d < N; d++) _chainLeader[d] = _chainCandidate[trial*N+d];
 }
}

double Korali::Solver::MCMC::recursiveAlpha(double& denom, const double llk0, const double* logliks, size_t N) const
{
 // recursive formula from Trias[2009]

 if(N==0)
 {
  denom = exp(llk0);
  return std::min(1.0, exp(logliks[0] - llk0));
 }
 else
 {
  // revert sample array
  double* revLlks = new double[N];
  for(size_t i = 0; i < N; ++i) revLlks[i] = logliks[N-1-i];
  
  // update numerator (w. recursive calls)
  double numerator = std::exp(logliks[N]);
  for(size_t i = 0; i < N; ++i)
  {
   double denom2;
   double recalpha2 = recursiveAlpha(denom2, logliks[N], revLlks, i);
   numerator *=  ( 1.0 - recalpha2 );
  }
  delete [] revLlks;

  if (numerator == 0.0) return 0.0;

  // update denomiator
  double denom1;
  double recalpha1 = recursiveAlpha(denom1, llk0, logliks, N-1);
  denom = denom1 * (1.0 - recalpha1);

  return std::min(1.0, numerator/denom);
 }
}


void Korali::Solver::MCMC::updateDatabase(std::vector<double>& point, double loglik)
{
 for (size_t d = 0; d < N; d++) _sampleDatabase[_databaseEntryCount*N + d] = point[d];
 _sampleFitnessDatabase[_databaseEntryCount] = loglik;
 _databaseEntryCount++;
}


void Korali::Solver::MCMC::generateCandidate(size_t sampleIdx)
{  
 size_t initialgens = _proposedSampleCount;
 sampleCandidate(sampleIdx); _proposedSampleCount++;
 setCandidatePriorAndCheck(sampleIdx);
 
 /*do { /TODO: fix check (DW)
   sampleCandidate(level); _proposedSampleCount++;
   setCandidatePriorAndCheck(level);
   if ( (_proposedSampleCount - initialgens) > _maxresamplings)
     Korali::logError(exiting resampling loop, max resamplings (%zu) reached.\n", _maxresamplings);
  } while (setCandidatePriorAndCheck(level)); */
}

void Korali::Solver::MCMC::evaluateSample()
{
 std::vector<double> _logTransformedSample(N);

 for(size_t d = 0; d<N; ++d)
   if (_k->_problem->getVariable(d)->_isLogSpace == true)
       _logTransformedSample[d] = std::exp(_chainCandidate[_currentRejectionCount*N+d]);
   else
       _logTransformedSample[d] = _chainCandidate[_currentRejectionCount*N+d];

  _k->_conduit->evaluateSample(_logTransformedSample.data(), _currentRejectionCount);
}

void Korali::Solver::MCMC::sampleCandidate(size_t sampleIdx)
{  
 for (size_t d = 0; d < N; ++d) _chainCandidate[sampleIdx*N+d] = 0.0;

 if ( (_useAdaptiveSampling == false) || (_databaseEntryCount <= _nonAdaptionPeriod + _burnIn))
     for (size_t d = 0; d < N; ++d) for (size_t e = 0; e < N; ++e) _chainCandidate[sampleIdx*N+d] += _choleskyDecompositionCovariance[d*N+e] * _gaussianGenerator->getRandomNumber();
 else
     for (size_t d = 0; d < N; ++d) for (size_t e = 0; e < N; ++e) _chainCandidate[sampleIdx*N+d] += _choleskyDecompositionChainCovariance[d*N+e] * _gaussianGenerator->getRandomNumber();

 for (size_t d = 0; d < N; ++d) _chainLeader[d] += _chainCandidate[sampleIdx*N+d];
}

bool Korali::Solver::MCMC::setCandidatePriorAndCheck(size_t sampleIdx)
{
 _chainCandidatesLogPriors[sampleIdx] = _k->_problem->evaluateSampleLogPrior(&_chainCandidate[N*sampleIdx]);
 if (_chainCandidatesLogPriors[sampleIdx] > -INFINITY) return true;
 return false;
}

void Korali::Solver::MCMC::updateState()
{

 _acceptanceRate = ( (double)_acceptanceCount/ (double)_chainLength );

 if(_databaseEntryCount == 1) for (size_t d = 0; d < N; d++) _chainMean[d] = _chainLeader[d];
 if(_databaseEntryCount <= 1) return;
 
 for (size_t d = 0; d < N; d++) for (size_t e = 0; e < d; e++)
 {
   _chainCovariancePlaceholder[d*N+e] = (_chainMean[d] - _chainLeader[d]) * (_chainMean[e] - _chainLeader[e]);
   _chainCovariancePlaceholder[e*N+d] = (_chainMean[d] - _chainLeader[d]) * (_chainMean[e] - _chainLeader[e]);
 }
 for (size_t d = 0; d < N; d++) _chainCovariancePlaceholder[d*N+d] = (_chainMean[d] - _chainLeader[d]) * (_chainMean[d] - _chainLeader[d]);

 // Chain Mean
 for (size_t d = 0; d < N; d++) _chainMean[d] = (_chainMean[d] * (_databaseEntryCount-1) + _chainLeader[d]) / _databaseEntryCount;
 
 // Chain Covariance (upper and lower triangle)
 for (size_t d = 0; d < N; d++) for (size_t e = 0; e < d; e++)
 {
   _chainCovariance[d*N+e] = (_databaseEntryCount-2.0)/(_databaseEntryCount-1.0) * _chainCovariance[d*N+e] + (_chainCovarianceScaling/_databaseEntryCount)*_chainCovariancePlaceholder[d*N+e];
   _chainCovariance[e*N+d] = (_databaseEntryCount-2.0)/(_databaseEntryCount-1.0) * _chainCovariance[d*N+e] + (_chainCovarianceScaling/_databaseEntryCount)*_chainCovariancePlaceholder[d*N+e];
 }

 // Chain Covariance (diagonal)
 for (size_t d = 0; d < N; d++)
   _chainCovariance[d*N+d] = (_databaseEntryCount-2.0)/(_databaseEntryCount-1.0) * _chainCovariance[d*N+d] + (_chainCovarianceScaling/_databaseEntryCount)*_chainCovariancePlaceholder[d*N+d];

 choleskyDecomp(_chainCovariance, _choleskyDecompositionChainCovariance);
}

void Korali::Solver::MCMC::printGeneration()
{
 Korali::logInfo(KORALI_MINIMAL, "Database Entries %ld\n", _databaseEntryCount);

 Korali::logInfo(KORALI_NORMAL, "Accepted Samples: %zu\n", _acceptanceCount);
 Korali::logInfo(KORALI_NORMAL, "Acceptance Rate Proposals: %.2f%%\n", 100*_acceptanceRate);

 Korali::logInfo(KORALI_DETAILED, "Variable = (Current Sample, Current Candidate):\n");
 for (size_t d = 0; d < N; d++)  Korali::logData(KORALI_DETAILED, "         %s = (%+6.3e, %+6.3e)\n", _k->_problem->getVariable(d)->_name.c_str(), _chainLeader[d], _chainCandidate[d]);
 Korali::logInfo(KORALI_DETAILED, "Current Chain Mean:\n");
 for (size_t d = 0; d < N; d++) Korali::logData(KORALI_DETAILED, " %s = %+6.3e\n", _k->_problem->getVariable(d)->_name.c_str(), _chainMean[d]);
 Korali::logInfo(KORALI_DETAILED, "Current Chain Covariance:\n");
 for (size_t d = 0; d < N; d++)
 {
  for (size_t e = 0; e <= d; e++) Korali::logData(KORALI_DETAILED, "   %+6.3e  ", _chainCovariance[d*N+e]);
  Korali::logInfo(KORALI_DETAILED, "\n");
 }
}

void Korali::Solver::MCMC::finalize()
{
 Korali::logInfo(KORALI_MINIMAL, "Number of Generated Samples: %zu\n", _proposedSampleCount);
 Korali::logInfo(KORALI_MINIMAL, "Acceptance Rate: %.2f%%\n", 100*_acceptanceRate);
 if (_maxChainLength == _chainLength) Korali::logInfo(KORALI_MINIMAL, "Max Samples Reached.\n");
}
