#include "engine/engine.hpp"
#include "conduit/conduit.hpp"
#include "solver/solver.hpp"
#include "problem/problem.hpp"
#include "conduit/MPI/MPI.hpp"
#include "auxiliar/py2json.hpp"
#include "auxiliar/fs.hpp"
#include <chrono>
#include <sys/types.h>
#include <sys/stat.h>
#include <cstdio>
#include <map>

std::vector<korali::Engine*> korali::_engineVector;
korali::Engine* korali::_currentEngine;
cothread_t korali::_mainThread;

namespace korali { void threadWrapper() { _currentEngine->run(); } }

void korali::Engine::run()
{
  auto t0 = std::chrono::system_clock::now();

  _solver->getConfiguration(_js["Solver"]);
  co_switch(korali::_mainThread);

  _currentGeneration++;
  _startingGeneration = _currentGeneration;

  while(_solver->checkTermination() == false)
  {
   if (_currentGeneration % _consoleFrequency == 0)
   {
    korali::logInfo("Minimal",  "--------------------------------------------------------------------\n");
    korali::logInfo("Minimal",  "Current Generation: #%zu\n", _currentGeneration);
    _solver->printGenerationBefore();
   }

   // Timing and Profiling Start
   auto t0 = std::chrono::system_clock::now();

   _solver->runGeneration();

   // Timing and Profiling End
   auto t1 = std::chrono::system_clock::now();

   if (_currentGeneration % _consoleFrequency == 0)
   {
    _solver->printGenerationAfter();
    korali::logInfo("Detailed", "Engine: %lu - Generation Time: %.3fs\n", _engineId, std::chrono::duration<double>(t1-t0).count());
   }

   if (_saveFrequency > 0)
   if (_currentGeneration % _saveFrequency == 0) saveState();

   _currentGeneration++;
  }

  auto t1 = std::chrono::system_clock::now();

  // Saving last generation and final.json
  _currentGeneration--;
  _isFinished = true;
  saveState();

  korali::logInfo("Minimal", "--------------------------------------------------------------------\n");
  korali::logInfo("Minimal", "%s finished correctly.\n", _solver->getType().c_str());
  for (size_t i = 0; i < _solver->_terminationCriteria.size(); i++) korali::logInfo("Normal", "Termination Criterion Met: %s\n", _solver->_terminationCriteria[i].c_str());
  _solver->finalize();
  korali::logInfo("Normal", "Final Generation: %lu\n", _currentGeneration);
  korali::logInfo("Normal", "Elapsed Time: %.3fs\n", std::chrono::duration<double>(t1-t0).count());

  co_switch(korali::_mainThread);
  korali::logError("Trying to continue finished Engine thread.\n");
}

void korali::Engine::saveState()
{
 char genFileName[256];

 sprintf(genFileName, "gen%05d.json", _currentGeneration);

 // Getting configuration
 _solver->getConfiguration(_js["Solver"]);
 _js["Internal"]["Run ID"] = _runID;
 _js["Internal"]["Current Generation"] = _currentGeneration;
 std::string fileName = "./" + _resultPath + "/" + genFileName;
 korali::JsonInterface::saveJsonToFile(fileName.c_str(), _js.getJson());
}

void korali::Engine::loadPreviousRun(nlohmann::json& js, std::string path)
{
 js["Internal"]["Current Generation"] = 0;
 js["Internal"]["Run ID"] = 0;

 if (korali::dirExists(path))
 {
  // Loading config file, if exists
  for (const auto & entry : korali::listDirFiles(path))
  {
   std::string filePath = entry;
   if (filePath.find("config.json", 0) != std::string::npos)
    if (korali::JsonInterface::loadJsonFromFile(js, filePath.c_str()) == false) korali::logError("Error loading initial configuration file.\n");
  }

  // Loading latest solver generation
  for (const auto & entry : korali::listDirFiles(path))
  {
   std::string filePath = entry;
   std::string fileExt = ".json";
   if (filePath.find("gen", 0) != std::string::npos)
   if (filePath.compare(filePath.size() - fileExt.size(), fileExt.size(), fileExt) == 0)
   {
    auto curJs = nlohmann::json();
    if (korali::JsonInterface::loadJsonFromFile(curJs, filePath.c_str()))
    {
     size_t runId = js["Internal"]["Run ID"];
     size_t currentGenRunId = curJs["Internal"]["Run ID"];
     if (currentGenRunId == runId)
     {
      size_t curGen = curJs["Internal"]["Current Generation"];
      if (curGen > js["Internal"]["Current Generation"])
      {
       js["Solver"] = curJs["Solver"];
       js["Internal"]["Current Generation"] = curGen;
      }
     }
    }
   }
  }
 }
}

void korali::Engine::initialize()
{
 _k = this;

 korali::listDirFiles(".");

 // Setting Run ID
 _runID = 0;
 _currentGeneration = 0;

 auto js = _js.getJson();
 setConfiguration(_js.getJson());
 _js.getJson() = js;

 // Loading any previous results, if so configured
 if (_resumePrevious)
 {
  loadPreviousRun(js, _resultPath);
  _currentGeneration = js["Internal"]["Current Generation"];
  _runID = js["Internal"]["Run ID"];
 }
 // Establishing Run ID, if not set by previous run
 if (_runID == 0) _runID = korali::getTimehash();

 // Saving initial configuration
 if (_currentGeneration == 0)
 {
  // Creating results directory
  korali::mkdir(_resultPath);
  saveConfig(js);
 }

 if (_currentGeneration > 0) _solver->setConfiguration(js["Solver"]);

 _isFinished = false;
 _thread = co_create(10240*sizeof(void*), korali::threadWrapper);
 co_switch(_thread);

 // Initializing Modules
 for (size_t i = 0; i < _distributions.size(); i++) _distributions[i]->initialize();
 _problem->initialize();
 _solver->initialize();
}

korali::Engine::Engine(nlohmann::json js) : korali::Engine::Engine()
{
 _js.getJson() = js;
 _k = this;
 _k->initialize();
}

void korali::Engine::saveConfig(nlohmann::json& js)
{
 _js._js = js;
 js["Internal"]["Run ID"] = _runID;
 std::string fileName = "./" + _resultPath + "/config.json";
 korali::JsonInterface::saveJsonToFile(fileName.c_str(), js);
}

void korali::Engine::loadConfig(std::string fileName)
{
 if (korali::JsonInterface::loadJsonFromFile(_js.getJson(), fileName.c_str()) == false)
   korali::logError("Could not find or load configuration file.\n");
}

nlohmann::json& korali::Engine::operator[](const std::string& key) { return _js[key]; }
nlohmann::json& korali::Engine::operator[](const unsigned long int& key) { return _js[key]; }
pybind11::object korali::Engine::getItem(pybind11::object key) { return _js.getItem(key); }
void korali::Engine::setItem(pybind11::object key, pybind11::object val) { _js.setItem(key, val); }
