#include "engine/engine.hpp"
#include "conduit/conduit.hpp"
#include "solver/solver.hpp"
#include "problem/problem.hpp"
#include "sample/sample.hpp"
#include "conduit/mpi/mpi.hpp"

#include "pybind11/pybind11.h"
#include "pybind11/functional.h"
#include "pybind11/stl.h"

#include <chrono>
#include <sys/types.h>
#include <sys/stat.h>
#include <cstdio>

void korali::Engine::start(bool isDryRun)
{
 // Setting Run ID
 _runID = korali::getTimehash();

 // Setting Configuration
 setConfiguration(_js);

 // Initializing Korali and its modules
 initialize();

 // If this is a worker process (not root), there's nothing else to do
 if (_conduit->isRoot() == false) return;

 // If this is a dry run and configuration succeeded, print sucess and return
 if (isDryRun)
 {
  saveState("dry.json");
  korali::logInfo("Minimal",  "--------------------------------------------------------------------\n");
  korali::logInfo("Minimal",  "Dry Run Successful.\n");
  korali::logInfo("Minimal",  "--------------------------------------------------------------------\n");
  return;
 }

 // Saving initial state
 saveState("initial.json");

 auto startTime = std::chrono::system_clock::now();

 // Running Solver by generations until at least one termination criterion is satisfied
 while(isExecutionFinished() == false)
 {
  if (_currentGeneration % _consoleOutputFrequency == 0)
    {
     korali::logInfo("Minimal",  "--------------------------------------------------------------------\n");
     korali::logInfo("Minimal",  "Starting Generation: #%zu\n", _currentGeneration);
     _solver->printGenerationBefore();
    }

  auto t0 = std::chrono::system_clock::now();

  _solver->runGeneration();

  auto t1 = std::chrono::system_clock::now();

  if (_currentGeneration % _consoleOutputFrequency == 0)
  {
   _solver->printGenerationAfter();
   korali::logInfo("Detailed", "Generation Time: %.3fs\n", std::chrono::duration<double>(t1-t0).count());
  }

  if (_currentGeneration % _resultsOutputFrequency == 0) saveState(_currentGeneration);

  _currentGeneration++;
 }

 _currentGeneration--;

 // Saving last generation and final.json
 saveState(_currentGeneration);
 saveState("final.json");

 auto endTime = std::chrono::system_clock::now();

 korali::logInfo("Minimal", "--------------------------------------------------------------------\n");
 korali::logInfo("Minimal", "%s finished correctly.\n", _solver->getType().c_str(), _currentGeneration);
 for (size_t i = 0; i < _solver->_terminationCriteria.size(); i++) korali::logInfo("Normal", "Termination Criterion Met: %s\n", _solver->_terminationCriteria[i].c_str());
 for (size_t i = 0; i < _problem->_terminationCriteria.size(); i++) korali::logInfo("Normal", "Termination Criterion Met: %s\n", _problem->_terminationCriteria[i].c_str());
 for (size_t i = 0; i < _conduit->_terminationCriteria.size(); i++) korali::logInfo("Normal", "Termination Criterion Met: %s\n", _conduit->_terminationCriteria[i].c_str());

 _solver->finalize();
 _problem->finalize();
 _conduit->finalize();

 korali::logInfo("Normal", "Total Generations: %lu\n", _currentGeneration);
 korali::logInfo("Normal", "Total Computational Model Evaluations: %lu\n", _conduit->_modelEvaluationCount);
 korali::logInfo("Normal", "Elapsed Time: %.3fs\n", std::chrono::duration<double>(endTime-startTime).count());
 korali::logInfo("Normal", "Results saved to folder: '%s'\n", _resultsOutputPath.c_str());
}

void korali::Engine::initialize()
{
 korali::setVerbosityLevel(_consoleOutputVerbosity);

 // Creating Results directory
 mkdir(_resultsOutputPath.c_str(), S_IRWXU | S_IRWXG | S_IROTH | S_IXOTH);

 // Initializing Modules
 _problem->initialize();
 _solver->initialize();
 _conduit->initialize();
}

korali::Engine::Engine()
{
 _opt = &_js;
 _k = this;
}

korali::Engine::Engine(nlohmann::json js) : korali::Engine::Engine()
{
 _js = js;
 setConfiguration(_js);
}

bool korali::Engine::isExecutionFinished()
{
  return _solver->checkTermination() || _conduit->checkTermination() || _problem->checkTermination();
}

void korali::Engine::saveState(std::string fileName)
{
 // Updating run timestamp
 _timestamp = korali::getTimestamp();

 // Getting configuration
 _js = nlohmann::json();
 this->getConfiguration(_js);

 // Only the root rank saves files
 if (!_conduit->isRoot()) return;
 fileName = "./" + _resultsOutputPath + "/" + fileName;
 korali::JsonInterface::saveJsonToFile(fileName.c_str(), _js);
}

void korali::Engine::saveState(int fileId)
{
 if (!_conduit->isRoot()) return;

 char fileName[256];

 sprintf(fileName, "s%05d.json", fileId);

 saveState(fileName);
}

void korali::Engine::loadState(std::string fileName)
{
 _js = korali::JsonInterface::loadJsonFromFile(fileName.c_str());
}

void korali::Engine::setItem(const std::string& key, const std::function<void(korali::Sample&)> val)
{
 size_t pos = _models.size();
 _models.push_back(val);
 (*_opt)[key] = pos;
 _opt = &_js;
}

void korali::Engine::setItem(const int& key, const std::function<void(korali::Sample&)> val)
{
 size_t pos = _models.size();
 _models.push_back(val);
 (*_opt)[key] = pos;
 _opt = &_js;
}

void korali::Engine::operator=(const std::function<void(korali::Sample&)> val)
{
 size_t pos = _models.size();
 _models.push_back(val);
 (*_opt) = pos;
 _opt = &_js;
}

double korali::Engine::getValue()
{
 double val = 0.0;
 if (_opt->is_number()) val = *_opt;
 else korali::logError("[Korali] Error: Attempted getValue() on non-numeric field.\n");
 _opt = &_js;
 return val;
}

bool korali::Engine::getBoolean()
{
 bool tf = false;
 if (_opt->is_boolean()) tf = *_opt;
 else korali::logError("[Korali] Error: Attempted getBoolean() on non-boolean field.\n");
 _opt = &_js;
 return tf;
}

std::string korali::Engine::getString()
{
 std::string str;
 if (_opt->is_string()) str = *_opt;
 else korali::logError("[Korali] Error: Attempted getString() on non-string field.\n");
 _opt = &_js;
 return str;
}

std::vector<double> korali::Engine::getArray()
{
 std::vector<double> vec;
 if (_opt->is_array() && (*_opt)[0].is_number()) vec = _opt->get<std::vector<double>>();
 else korali::logError("[Korali] Error: Attempted getArray() on non-array field or non-numeric array.\n");
 _opt = &_js;
 return vec;
}

#ifdef _KORALI_USE_MPI
long int korali::Engine::getMPICommPointer() { return (long int)(&__KoraliTeamComm); }
#endif

PYBIND11_MODULE(libkorali, m)
{
  pybind11::class_<korali::Sample>(m, "Sample")
    .def("__getitem__",     &korali::Sample::operator[], pybind11::return_value_policy::reference)
    .def("getSampleId",  &korali::Sample::getSampleId, pybind11::return_value_policy::reference)
    .def("getSampleData",  &korali::Sample::getSampleData, pybind11::return_value_policy::reference)
    .def("setResult", pybind11::overload_cast<const double&>(&korali::Sample::setResult), pybind11::return_value_policy::reference)
    .def("setResult", pybind11::overload_cast<const std::vector<double>&>(&korali::Sample::setResult), pybind11::return_value_policy::reference);

 pybind11::class_<korali::Engine>(m, "Engine")
   .def(pybind11::init<>())
   .def("getValue", &korali::Engine::getValue)
   .def("getBoolean", &korali::Engine::getBoolean)
   .def("getString", &korali::Engine::getString)
   .def("getArray", &korali::Engine::getArray)
    #ifdef _KORALI_USE_MPI
   .def("getMPIComm", &korali::Engine::getMPICommPointer)
    #endif
   .def("__getitem__", pybind11::overload_cast<const std::string&>(&korali::Engine::getItem), pybind11::return_value_policy::reference)
   .def("__getitem__", pybind11::overload_cast<const unsigned long int&>(&korali::Engine::getItem), pybind11::return_value_policy::reference)
   .def("__setitem__", pybind11::overload_cast<const std::string&, const std::function<void(korali::Sample&)>>(&korali::Engine::setItem), pybind11::return_value_policy::reference)
   .def("__setitem__", pybind11::overload_cast<const std::string&, const std::string&>(&korali::Engine::setItem), pybind11::return_value_policy::reference)
   .def("__setitem__", pybind11::overload_cast<const std::string&, const double&>(&korali::Engine::setItem), pybind11::return_value_policy::reference)
   .def("__setitem__", pybind11::overload_cast<const std::string&, const int&>(&korali::Engine::setItem), pybind11::return_value_policy::reference)
   .def("__setitem__", pybind11::overload_cast<const std::string&, const std::vector<double>&>(&korali::Engine::setItem), pybind11::return_value_policy::reference)
   .def("__setitem__", pybind11::overload_cast<const int&, const std::function<void(korali::Sample&)>>(&korali::Engine::setItem), pybind11::return_value_policy::reference)
   .def("__setitem__", pybind11::overload_cast<const int&, const std::string&>(&korali::Engine::setItem), pybind11::return_value_policy::reference)
   .def("__setitem__", pybind11::overload_cast<const int&, const double&>(&korali::Engine::setItem), pybind11::return_value_policy::reference)
   .def("__setitem__", pybind11::overload_cast<const int&, const int&>(&korali::Engine::setItem), pybind11::return_value_policy::reference)
   .def("run", &korali::Engine::run)
   .def("dry", &korali::Engine::dry)
   .def("loadState",     &korali::Engine::loadState, pybind11::return_value_policy::reference);
}


