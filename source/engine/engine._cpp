#include "engine/engine.hpp"
#include "conduit/conduit.hpp"
#include "solver/solver.hpp"
#include "problem/problem.hpp"
#include "conduit/MPI/MPI.hpp"
#include "auxiliar/py2json.hpp"

#include <chrono>
#include <sys/types.h>
#include <sys/stat.h>
#include <cstdio>
#include <map>
#include <filesystem>

korali::Engine* korali::_currentEngine;
cothread_t korali::_mainThread;

namespace korali { void threadWrapper() { _currentEngine->run(); } }

void korali::Engine::run()
{
  co_switch(korali::_mainThread);

  auto t0 = std::chrono::system_clock::now();

  _currentGeneration++;
  _startingGeneration = _currentGeneration;

  while(checkTermination() == false)
  {
   if (_currentGeneration % _consoleFrequency == 0)
   {
    korali::logInfo("Minimal",  "--------------------------------------------------------------------\n");
    korali::logInfo("Minimal",  "Current Generation: #%zu\n", _currentGeneration);
    _solver->printGenerationBefore();
   }

   // Timing and Profiling Start
   auto t0 = std::chrono::system_clock::now();

   _solver->runGeneration();

   // Timing and Profiling End
   auto t1 = std::chrono::system_clock::now();

   if (_currentGeneration % _consoleFrequency == 0)
   {
    _solver->printGenerationAfter();
    korali::logInfo("Detailed", "Engine: %lu - Generation Time: %.3fs\n", _engineId, std::chrono::duration<double>(t1-t0).count());
   }

   if (_saveFrequency > 0)
   if (_currentGeneration % _saveFrequency == 0) saveState();

   _currentGeneration++;
  }

  auto t1 = std::chrono::system_clock::now();

  // Saving last generation and final.json
  _currentGeneration--;
  _isFinished = true;
  saveState();

  korali::logInfo("Minimal", "--------------------------------------------------------------------\n");
  korali::logInfo("Minimal", "%s finished correctly.\n", getType().c_str());
  for (size_t i = 0; i < _terminationCriteria.size(); i++) korali::logInfo("Normal", "Termination Criterion Met: %s\n", _terminationCriteria[i].c_str());
  finalize();
  korali::logInfo("Normal", "Final Generation: %lu\n", _currentGeneration);
  korali::logInfo("Normal", "Elapsed Time: %.3fs\n", std::chrono::duration<double>(t1-t0).count());

  co_switch(korali::_mainThread);
  korali::logError("Trying to continue finished Engine thread.\n");
}

void korali::Engine::saveState()
{
 char genFileName[256];

 sprintf(genFileName, "gen%05d.json", _currentGeneration);

 // Getting configuration
 auto js = nlohmann::json();
 this->getConfiguration(js);

 std::string fileName = "./" + _resultPath + "/" + genFileName;
 korali::JsonInterface::saveJsonToFile(fileName.c_str(), js);
}


void korali::Engine::loadPreviousResult(nlohmann::json& solverJs, std::string engineDir)
{
 size_t maxGeneration = 0;

 if (std::filesystem::exists(engineDir))
 for (const auto & entry : std::filesystem::directory_iterator(engineDir))
 {
  std::string filePath = entry.path();
  std::string fileExt = ".json";
  if (filePath.compare(filePath.size() - fileExt.size(), fileExt.size(), fileExt) == 0)
  {
   auto curJs = nlohmann::json();
   if (korali::JsonInterface::loadJsonFromFile(curJs, filePath.c_str()))
   {
    size_t curGen = curJs["Internal"]["Current Generation"];
    if (curGen > maxGeneration)
    {
     solverJs = curJs;
     maxGeneration = curGen;
    }
   }
  }
 }
}

void korali::Engine::initialize()
{
 _k = this;

 // Setting Run ID
 _runID = korali::getTimehash();

 auto js = _js.getJson();
 setConfiguration(_js.getJson());
 if (_resumePrevious) loadPreviousResult(_js.getJson(), _resultPath);

 // Creating results directory
 mkdir(_resultPath.c_str(), S_IRWXU | S_IRWXG | S_IROTH | S_IXOTH);

 // Saving initial configuration
 saveConfig(js);

 _isFinished = false;
 _thread = co_create(10240*sizeof(void*), korali::threadWrapper);

 _currentEngine = this;
 co_switch(_thread);

 // Initializing Modules
 for (size_t i = 0; i < _distributions.size(); i++) _distributions[i]->initialize();
 _problem->initialize();
 _solver->initialize();
}

korali::Engine::Engine(nlohmann::json js) : korali::Engine::Engine()
{
 _js.getJson() = js;
 setConfiguration(_js.getJson());
}

void korali::Engine::saveConfig(nlohmann::json& js)
{
 _js._js = js;
 js["Run ID"] = _runID;
 js["Start Time"] = korali::getTimestamp();
 std::string fileName = "./" + _resultPath + "/config.json";
 korali::JsonInterface::saveJsonToFile(fileName.c_str(), js);
}

void korali::Engine::loadConfig(std::string fileName)
{
 if (korali::JsonInterface::loadJsonFromFile(_js.getJson(), fileName.c_str()) == false)
   korali::logError("Could not find or load configuration file.\n");
}

nlohmann::json& korali::Engine::operator[](const std::string& key) { return _js[key]; }
nlohmann::json& korali::Engine::operator[](const unsigned long int& key) { return _js[key]; }
pybind11::object korali::Engine::getItem(pybind11::object key) { return _js.getItem(key); }
void korali::Engine::setItem(pybind11::object key, pybind11::object val) { _js.setItem(key, val); }
