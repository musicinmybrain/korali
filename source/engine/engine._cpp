#include "engine/engine.hpp"
#include "conduit/conduit.hpp"
#include "solver/solver.hpp"
#include "problem/problem.hpp"
#include "conduit/MPI/MPI.hpp"
#include "auxiliar/py2json.hpp"

#include <chrono>
#include <sys/types.h>
#include <sys/stat.h>
#include <cstdio>
#include <map>

void korali::Engine::run()
{
 // Setting output file to stdout, by default.
 korali::setConsoleOutputFile(stdout);

 // Setting Run ID
 _runID = korali::getTimehash();

 // Setting Configuration
 auto js = _js.getJson();
 setConfiguration(_js.getJson());

 // Initializing Korali and its modules
 initialize();

 // Creating results directory
 mkdir(_resultPath.c_str(), S_IRWXU | S_IRWXG | S_IROTH | S_IXOTH);

 // Saving initial configuration
 saveConfig(js);

 // If this is a worker process (not root), there's nothing else to do
 if (_conduit->isRoot() == false) return;

 // Creating solvers.
 auto solvers = std::vector<korali::Solver*>(_solverCount);

 for (size_t i = 0; i < _solverCount; i++)
 {
  auto solverJs = js["Solver"];
  solvers[i] = dynamic_cast<korali::Solver*>(korali::Module::getModule(solverJs));

  char dirName[256];
  sprintf(dirName, "solver%05d", i);
  solvers[i]->_subDirPath = _resultPath + "/" + dirName;
  std::string fileName = "./" + solvers[i]->_subDirPath + "/log.txt";
  if (_solverCount > 1) solvers[i]->_logFile = fopen(fileName.c_str(),"a");
  mkdir(solvers[i]->_subDirPath.c_str(), S_IRWXU | S_IRWXG | S_IROTH | S_IXOTH);

  solvers[i]->_solverId = i;
  solvers[i]->_runID = _runID;
  solvers[i]->initialize();
  solvers[i]->_thread = co_create(10240*sizeof(void*), korali::Solver::solverWrapper);

  _currentSolver = solvers[i];
  co_switch(solvers[i]->_thread);
 }

 // If this is a dry run and configuration succeeded, print sucess and return
 if (_dryRun)
 {
  korali::logInfo("Minimal",  "--------------------------------------------------------------------\n");
  korali::logInfo("Minimal",  "Dry Run Successful.\n");
  korali::logInfo("Minimal",  "--------------------------------------------------------------------\n");
  return;
 }

 // Setting start time.
 _startTime = std::chrono::high_resolution_clock::now();

 while(true)
 {
  bool executed = false;

  for (size_t i = 0; i < _solverCount; i++) if (solvers[i]->_isFinished == false)
  {
   if (_solverCount > 1) korali::setConsoleOutputFile(solvers[i]->_logFile);
   _currentSolver = solvers[i];

   co_switch(solvers[i]->_thread);

   if (_solverCount > 1) korali::setConsoleOutputFile(stdout);
   executed = true;
   if (_solverCount > 1) if (solvers[i]->_isFinished == true) korali::logInfo("Normal", "Job %lu has finished.\n", i);
  }

  if (executed == false) break;
 }

 if (_solverCount > 1) korali::logInfo("Minimal", "All jobs have finished correctly.\n");
 if (_solverCount > 1) korali::logInfo("Normal", "Elapsed Time: %.3fs\n", std::chrono::duration<double>(std::chrono::high_resolution_clock::now()-_startTime).count());
 korali::logInfo("Normal", "Results saved to folder: '%s'\n", _resultPath.c_str());

 saveProfilingInfo();
}

void korali::Engine::initialize()
{
 korali::setVerbosityLevel(_verbosity);

 // Initializing Modules
 for (size_t i = 0; i < _k->_distributions.size(); i++) _k->_distributions[i]->initialize();
 _problem->initialize();
 _conduit->initialize();
 _thread = co_active();
}

korali::Engine::Engine()
{
 _k = this;
}

korali::Engine::Engine(nlohmann::json js) : korali::Engine::Engine()
{
 _js.getJson() = js;
 setConfiguration(_js.getJson());
}

void korali::Engine::saveConfig(nlohmann::json& js)
{
 js["Run ID"] = _runID;
 js["Start Time"] = korali::getTimestamp();
 std::string fileName = "./" + _resultPath + "/config.json";
 korali::JsonInterface::saveJsonToFile(fileName.c_str(), js);
}

void korali::Engine::saveProfilingInfo()
{
 _timestamp = korali::getTimestamp();
 __profiler["Solver Count"] = _solverCount;
 __profiler["Elapsed Time"] = std::chrono::duration<double>(std::chrono::high_resolution_clock::now()-_startTime).count();
 std::string fileName = "./" + _resultPath + "/profiling.json";
 korali::JsonInterface::saveJsonToFile(fileName.c_str(), __profiler);
}

void korali::Engine::loadConfig(std::string fileName)
{
 if (korali::JsonInterface::loadJsonFromFile(_js.getJson(), fileName.c_str()) == false)
   korali::logError("Could not find or load configuration file.\n");
}

nlohmann::json& korali::Engine::operator[](const std::string& key) { return _js[key]; }
nlohmann::json& korali::Engine::operator[](const unsigned long int& key) { return _js[key]; }
pybind11::object korali::Engine::getItem(pybind11::object key) { return _js.getItem(key); }
void korali::Engine::setItem(pybind11::object key, pybind11::object val) { _js.setItem(key, val); }

#ifdef _KORALI_USE_MPI
long int korali::Engine::getMPICommPointer() { return (long int)(&__KoraliTeamComm); }
#endif

PYBIND11_MODULE(libkorali, m)
{
 pybind11::class_<korali::KoraliJson>(m, "koraliJson")
  .def("__getitem__", pybind11::overload_cast<pybind11::object>(&korali::KoraliJson::getItem), pybind11::return_value_policy::reference)
  .def("__setitem__", pybind11::overload_cast<pybind11::object, pybind11::object>(&korali::KoraliJson::setItem), pybind11::return_value_policy::reference);

 pybind11::class_<korali::Sample>(m, "Sample")
  .def("__getitem__", pybind11::overload_cast<pybind11::object>(&korali::Sample::getItem), pybind11::return_value_policy::reference)
  .def("__setitem__", pybind11::overload_cast<pybind11::object, pybind11::object>(&korali::Sample::setItem), pybind11::return_value_policy::reference);

 pybind11::class_<korali::Engine>(m, "Engine")
   .def(pybind11::init<>())
    #ifdef _KORALI_USE_MPI
   .def("getMPIComm", &korali::Engine::getMPICommPointer)
    #endif
   .def("__getitem__", pybind11::overload_cast<pybind11::object>(&korali::Engine::getItem), pybind11::return_value_policy::reference)
   .def("__setitem__", pybind11::overload_cast<pybind11::object, pybind11::object>(&korali::Engine::setItem), pybind11::return_value_policy::reference)
   .def("run", &korali::Engine::run)
   .def("loadConfig",     &korali::Engine::loadConfig, pybind11::return_value_policy::reference);
}
