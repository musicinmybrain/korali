#include "engine/engine.hpp"
#include "conduit/conduit.hpp"
#include "solver/solver.hpp"
#include "problem/problem.hpp"
#include "conduit/MPI/MPI.hpp"
#include "auxiliar/py2json.hpp"

#include <chrono>
#include <sys/types.h>
#include <sys/stat.h>
#include <cstdio>
#include <map>

void korali::Engine::start(bool isDryRun)
{
 // Setting output file to stdout, by default.
 korali::setConsoleOutputFile(stdout);

 // Initializing Profile Information
 _profileInfo["Engine"].startSegment();

 // Setting Run ID
 _runID = korali::getTimehash();

 // Setting Configuration
 setConfiguration(_js.getJson());

 // Initializing Korali and its modules
 initialize();

 // If this is a worker process (not root), there's nothing else to do
 if (_conduit->isRoot() == false) return;

 // If this is a dry run and configuration succeeded, print sucess and return
 if (isDryRun)
 {
  saveState(_resultsOutputPath, "dry.json");
  korali::logInfo("Minimal",  "--------------------------------------------------------------------\n");
  korali::logInfo("Minimal",  "Dry Run Successful.\n");
  korali::logInfo("Minimal",  "--------------------------------------------------------------------\n");
  return;
 }

 // Saving initial state
 saveState(_resultsOutputPath, "initial.json");

 auto startTime = std::chrono::system_clock::now();

 // Running Solver by generations until at least one termination criterion is satisfied
 while(isExecutionFinished() == false)
 {
  if (_solver->_currentGeneration % _consoleOutputFrequency == 0)
  {
   korali::logInfo("Minimal",  "--------------------------------------------------------------------\n");
   korali::logInfo("Minimal",  "Starting Generation: #%zu\n", _solver->_currentGeneration);
   _solver->printGenerationBefore();
  }

  // Timing and Profiling Start
  auto t0 = std::chrono::system_clock::now();

  _profileInfo["Engine"].commitSegment();
  _profileInfo["Solver"].startSegment();
  _solver->runGeneration();
  _profileInfo["Solver"].commitSegment();
  _profileInfo["Engine"].startSegment();

  // Timing and Profiling End
  auto t1 = std::chrono::system_clock::now();

  if (_solver->_currentGeneration % _consoleOutputFrequency == 0)
  {
   _solver->printGenerationAfter();
   korali::logInfo("Detailed", "Generation Time: %.3fs\n", std::chrono::duration<double>(t1-t0).count());
  }

  if (_solver->_currentGeneration % _resultsOutputFrequency == 0) saveState(_resultsOutputPath, _solver->_currentGeneration);

  _solver->_currentGeneration++;
 }

 _solver->_currentGeneration--;

 // Saving last generation and final.json
 saveState(_resultsOutputPath, _solver->_currentGeneration);
 saveState(_resultsOutputPath, "final.json");

 auto endTime = std::chrono::system_clock::now();

 korali::logInfo("Minimal", "--------------------------------------------------------------------\n");
 korali::logInfo("Minimal", "%s finished correctly.\n", _solver->getType().c_str(), _solver->_currentGeneration);
 for (size_t i = 0; i < _solver->_terminationCriteria.size(); i++) korali::logInfo("Normal", "Termination Criterion Met: %s\n", _solver->_terminationCriteria[i].c_str());
 for (size_t i = 0; i < _problem->_terminationCriteria.size(); i++) korali::logInfo("Normal", "Termination Criterion Met: %s\n", _problem->_terminationCriteria[i].c_str());
 for (size_t i = 0; i < _conduit->_terminationCriteria.size(); i++) korali::logInfo("Normal", "Termination Criterion Met: %s\n", _conduit->_terminationCriteria[i].c_str());

 _solver->finalize();
 _problem->finalize();
 _conduit->finalize();

 korali::logInfo("Normal", "Total Generations: %lu\n", _solver->_currentGeneration);
 korali::logInfo("Normal", "Total Computational Model Evaluations: %lu\n", _conduit->_modelEvaluationCount);
 korali::logInfo("Normal", "Elapsed Time: %.3fs\n", std::chrono::duration<double>(endTime-startTime).count());

 _profileInfo["Engine"].commitSegment();
 for (auto& x : korali::_profileInfo)
   korali::logInfo("Detailed", "   [%s] Segments: %lu,  Busy Time: %f\n", x.first.c_str(), x.second._segmentTimes.size(), x.second._workTime);

 korali::logInfo("Normal", "Results saved to folder: '%s'\n", _resultsOutputPath.c_str());
}

korali::Solver* _currentSolver;
void korali::Engine::solverWrapper()
{
  korali::Solver* solver = _currentSolver;
  korali::Engine* engine = solver->_k;
  korali::Conduit* conduit = engine->_conduit;
  co_switch(engine->_thread);

  conduit->_thread = co_active();

  korali::setConsoleOutputFile(solver->_logFile);

  // Saving initial state
  engine->saveState(solver->_subDirPath, "initial.json");

  auto t0 = std::chrono::system_clock::now();

  while(solver->checkTermination() == false)
  {
   if (solver->_currentGeneration % engine->_consoleOutputFrequency == 0)
   {
    korali::logInfo("Minimal",  "--------------------------------------------------------------------\n");
    korali::logInfo("Minimal",  "Starting Generation: #%zu\n", solver->_currentGeneration);
    solver->printGenerationBefore();
   }

   // Timing and Profiling Start
   auto t0 = std::chrono::system_clock::now();

   solver->runGeneration();

   // Timing and Profiling End
   auto t1 = std::chrono::system_clock::now();

   if (solver->_currentGeneration % engine->_consoleOutputFrequency == 0)
   {
    solver->printGenerationAfter();
    korali::logInfo("Detailed", "Solver: %lu - Generation Time: %.3fs\n", solver->_solverId, std::chrono::duration<double>(t1-t0).count());
   }

   if (solver->_currentGeneration % engine->_resultsOutputFrequency == 0) engine->saveState(solver->_subDirPath, solver->_currentGeneration);

   solver->_currentGeneration++;
  }

  auto t1 = std::chrono::system_clock::now();

  solver->_currentGeneration--;

  // Saving last generation and final.json
  engine->saveState(solver->_subDirPath, solver->_currentGeneration);
  engine->saveState(solver->_subDirPath, "final.json");

  korali::logInfo("Minimal", "--------------------------------------------------------------------\n");
  korali::logInfo("Minimal", "%s finished correctly.\n", solver->getType().c_str(), solver->_currentGeneration);
  for (size_t i = 0; i < solver->_terminationCriteria.size(); i++) korali::logInfo("Normal", "Termination Criterion Met: %s\n", solver->_terminationCriteria[i].c_str());

  solver->finalize();

  korali::logInfo("Normal", "Total Generations: %lu\n", solver->_currentGeneration);
  korali::logInfo("Normal", "Elapsed Time: %.3fs\n", std::chrono::duration<double>(t1-t0).count());
  korali::logInfo("Normal", "Results saved to folder: '%s'\n", solver->_subDirPath.c_str());

  korali::setConsoleOutputFile(stdout);
  co_switch(engine->_thread);
}

void korali::Engine::runMultiple(size_t count)
{
 // Setting output file to stdout, by default.
 korali::setConsoleOutputFile(stdout);

 // Initializing Profile Information
 _profileInfo["Engine"].startSegment();

 // Setting Run ID
 _runID = korali::getTimehash();

 // Setting Configuration
 setConfiguration(_js.getJson());

 // Initializing Korali and its modules
 initialize();

 // If this is a worker process (not root), there's nothing else to do
 if (_conduit->isRoot() == false) return;

 _thread = co_active();
 auto solvers = std::vector<korali::Solver*>(count);

 for (size_t i = 0; i < count; i++)
 {
  auto js = nlohmann::json();
  getConfiguration(js);

  solvers[i] = dynamic_cast<korali::Solver*>(korali::Module::getModule(js["Solver"]));
  solvers[i]->initialize();
  solvers[i]->_thread = co_create(10240*sizeof(void*), korali::Engine::solverWrapper);
  solvers[i]->_solverId = i;

  // Creating Solver Results directory and logFile
  char dirName[256];
  sprintf(dirName, "solver%05d", i);
  solvers[i]->_subDirPath = _resultsOutputPath + "/" + dirName;
  mkdir(solvers[i]->_subDirPath.c_str(), S_IRWXU | S_IRWXG | S_IROTH | S_IXOTH);
  std::string fileName = "./" + solvers[i]->_subDirPath + "/log.txt";
  solvers[i]->_logFile = fopen(fileName.c_str(),"w");

  _currentSolver = solvers[i];
  co_switch(solvers[i]->_thread);
 }

 auto startTime = std::chrono::system_clock::now();

 for (size_t i = 0; i < count; i++)
 {
  co_switch(solvers[i]->_thread);
 }

 auto endTime = std::chrono::system_clock::now();

 korali::logInfo("Minimal", "All %lu jobs have finished correctly.\n", count);
 korali::logInfo("Normal", "Elapsed Time: %.3fs\n", std::chrono::duration<double>(endTime-startTime).count());
 korali::logInfo("Normal", "Results saved to folder: '%s'\n", _resultsOutputPath.c_str());
}

void korali::Engine::initialize()
{
 korali::setVerbosityLevel(_consoleOutputVerbosity);

 // Creating Results directory
 mkdir(_resultsOutputPath.c_str(), S_IRWXU | S_IRWXG | S_IROTH | S_IXOTH);

 // Initializing Modules
 for (size_t i = 0; i < _k->_distributions.size(); i++) _k->_distributions[i]->initialize();
 _problem->initialize();
 _solver->initialize();
 _conduit->initialize();

 // Setting default conduit thread
 _conduit->_thread = co_active();
}

korali::Engine::Engine()
{
 _k = this;
}

korali::Engine::Engine(nlohmann::json js) : korali::Engine::Engine()
{
 _js.getJson() = js;
 setConfiguration(_js.getJson());
}

bool korali::Engine::isExecutionFinished()
{
  return _solver->checkTermination() || _conduit->checkTermination() || _problem->checkTermination();
}

void korali::Engine::saveState(std::string dirName, std::string fileName)
{
 // Updating run timestamp
 _timestamp = korali::getTimestamp();

 // Getting configuration
 _js.getJson() = nlohmann::json();
 this->getConfiguration(_js.getJson());

 // Only the root rank saves files
 if (!_conduit->isRoot()) return;
 fileName = "./" + dirName + "/" + fileName;
 korali::JsonInterface::saveJsonToFile(fileName.c_str(), _js.getJson());
}

void korali::Engine::saveState(std::string dirName, int fileId)
{
 if (!_conduit->isRoot()) return;

 char fileName[256];

 sprintf(fileName, "gen%05d.json", fileId);

 saveState(dirName, fileName);
}

void korali::Engine::loadState(std::string fileName)
{
 _js.getJson() = korali::JsonInterface::loadJsonFromFile(fileName.c_str());
}

nlohmann::json& korali::Engine::operator[](const std::string& key) { return _js[key]; }
nlohmann::json& korali::Engine::operator[](const unsigned long int& key) { return _js[key]; }
pybind11::object korali::Engine::getItem(pybind11::object key) { return _js.getItem(key); }
void korali::Engine::setItem(pybind11::object key, pybind11::object val) { _js.setItem(key, val); }

#ifdef _KORALI_USE_MPI
long int korali::Engine::getMPICommPointer() { return (long int)(&__KoraliTeamComm); }
#endif

PYBIND11_MODULE(libkorali, m)
{
 pybind11::class_<korali::KoraliJson>(m, "koraliJson")
  .def("__getitem__", pybind11::overload_cast<pybind11::object>(&korali::KoraliJson::getItem), pybind11::return_value_policy::reference)
  .def("__setitem__", pybind11::overload_cast<pybind11::object, pybind11::object>(&korali::KoraliJson::setItem), pybind11::return_value_policy::reference);

 pybind11::class_<korali::Sample>(m, "Sample")
  .def("__getitem__", pybind11::overload_cast<pybind11::object>(&korali::Sample::getItem), pybind11::return_value_policy::reference)
  .def("__setitem__", pybind11::overload_cast<pybind11::object, pybind11::object>(&korali::Sample::setItem), pybind11::return_value_policy::reference);

 pybind11::class_<korali::Engine>(m, "Engine")
   .def(pybind11::init<>())
    #ifdef _KORALI_USE_MPI
   .def("getMPIComm", &korali::Engine::getMPICommPointer)
    #endif
   .def("__getitem__", pybind11::overload_cast<pybind11::object>(&korali::Engine::getItem), pybind11::return_value_policy::reference)
   .def("__setitem__", pybind11::overload_cast<pybind11::object, pybind11::object>(&korali::Engine::setItem), pybind11::return_value_policy::reference)
   .def("run", &korali::Engine::run)
   .def("runMultiple", &korali::Engine::runMultiple)
   .def("dry", &korali::Engine::dry)
   .def("loadState",     &korali::Engine::loadState, pybind11::return_value_policy::reference);
}


