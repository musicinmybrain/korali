#include "modules/solver/interpolator/interpolator.hpp"
#include "modules/conduit/conduit.hpp"

void korali::solver::Interpolator::setInitialConfiguration()
{
 // Initialize by populating the initial possibility space
 size_t policyCount = 1;
 size_t policyDepth = _k->_currentGeneration;
 size_t varCount = _k->_variables.size();

 _policyCollection.resize(_recursionDepth);

 for (size_t i = 0; i < _k->_variables.size(); i++) policyCount *= (_k->_variables[i]->_intervalCount+1);

 _policyCollection[0].resize(policyCount);
 for (size_t i = 0; i < policyCount; i++) _policyCollection[0][i].resize(varCount);

// printf("Combination Count: %lu, Var Count: %lu\n", policyCount, varCount);
 size_t currentStride = 1;

 for (int i = _k->_variables.size()-1; i >= 0; i--)
 {
  double intervalLength = (_k->_variables[i]->_upperBound + _k->_variables[i]->_lowerBound) / (double)_k->_variables[i]->_intervalCount;

  size_t currentPolicy = 0;
  while (currentPolicy < policyCount)
  for (size_t j = 0; j < _k->_variables[i]->_intervalCount+1; j++)
  {
   double point = (double)j * intervalLength;
   for (size_t k = 0; k < currentStride; k++)
   {
    _policyCollection[0][currentPolicy][i] = point;
    currentPolicy++;
   }
  }

  currentStride *= (_k->_variables[i]->_intervalCount+1);
 }

 // Evaluating Constraints
 std::vector<korali::Sample> cSamples(policyCount);
 std::vector<double> sampleData(_k->_variables.size());
 for (size_t i = 0; i < policyCount; i++)
 {
  for(size_t j = 0; j < varCount; j++) sampleData[j] = _policyCollection[0][i][j];
  cSamples[i]["Operation"]  = "Evaluate Constraints";
  cSamples[i]["Policy"][0] = sampleData;
  korali::_conduit->start(cSamples[i]);
 }

 korali::_conduit->waitAll(cSamples);

 // Pruning policies based on constraints
 for (int i = policyCount-1; i >= 0; i--)
 {
  double constraintEval = cSamples[i]["Constraint Evaluation"];
  if (constraintEval < 0)
   {
     // printf("i: %lu, Constraint Eval: %f\n", i, constraintEval);
     _policyCollection[0].erase(_policyCollection[0].begin() + i);
     policyCount--;
   }
 }

 std::vector<korali::Sample> eSamples(policyCount);
 for (size_t i = 0; i < policyCount; i++)
 {
  for(size_t j = 0; j < varCount; j++) sampleData[j] = _policyCollection[0][i][j];
  eSamples[i]["Operation"]  = "Evaluate Cost Function";
  eSamples[i]["Variables"] = sampleData;
  korali::_conduit->start(eSamples[i]);
 }

 korali::_conduit->waitAll(eSamples);

 _policyEvaluation.resize(policyCount);
 for (size_t i = 0; i < policyCount; i++)
 {
  double eval = eSamples[i]["Cost Evaluation"];
  _policyEvaluation[i] = eval;
 }

}

void korali::solver::Interpolator::runGeneration()
{

 if (_k->_currentGeneration == 1) { setInitialConfiguration(); return; }

 size_t currentDepth = _k->_currentGeneration-1;
 size_t policyCount = _policyCollection[currentDepth-1].size();
 size_t varCount = _k->_variables.size();

 _policyCollection[currentDepth].resize(policyCount);
 for (size_t i = 0; i < policyCount; i++) _policyCollection[currentDepth][i].resize(varCount);

 size_t candidateCount = 1;
 for (size_t i = 0; i < _k->_variables.size(); i++) candidateCount *= (_k->_variables[i]->_intervalCount+1);
 std::vector<double> candidateList(candidateCount * varCount);

 size_t currentStride = 1;
 for (int i = _k->_variables.size()-1; i >= 0; i--)
 {
  double intervalLength = (_k->_variables[i]->_upperBound + _k->_variables[i]->_lowerBound) / (double)_k->_variables[i]->_intervalCount;

  size_t currentCandidate = 0;
  while (currentCandidate < candidateCount)
  for (size_t j = 0; j < _k->_variables[i]->_intervalCount+1; j++)
  {
   double point = (double)j * intervalLength;
   for (size_t k = 0; k < currentStride; k++)
   {
    candidateList[currentCandidate*varCount + i] = point;
    currentCandidate++;
   }
  }

  currentStride *= (_k->_variables[i]->_intervalCount+1);
 }

 //printf("Candidate List Size: %lu\n", candidateList.size());

 std::vector<std::vector<std::vector<double>>> _newPolicyCollection(_recursionDepth);
 std::vector<double> _newPolicyEvaluations;

 for (size_t i = 0; i < policyCount; i++)
 {
  std::vector<korali::Sample> cSamples(candidateList.size());
  size_t currentSample = 0;

  for (size_t j = 0; j < candidateList.size(); j++)
  {
   for (size_t k = 0; k < varCount; k++) _policyCollection[currentDepth][i][k] = candidateList[j*varCount + k];

   for (size_t p = 0; p <= currentDepth; p++)
   {
    std::vector<double> coordinate(varCount);
    for (size_t k = 0; k < varCount; k++)  coordinate[k] = _policyCollection[p][i][k];
    cSamples[currentSample]["Policy"][p] = coordinate;
   }

   cSamples[currentSample]["Previous Evaluation"] = _policyEvaluation[i];
   cSamples[currentSample]["Operation"]  = "Evaluate Constraints";
   korali::_conduit->start(cSamples[currentSample]);
   currentSample++;
  }

  korali::_conduit->waitAll(cSamples);

  for (int j = candidateList.size()-1; j >= 0 ; j--)
  {
//   printf("Tried: ");
   for (size_t p = 0; p <= currentDepth; p++)
   {
//    printf("( ");
    for (size_t k = 0; k < varCount; k++)
    {
     double val = cSamples[j]["Policy"][p][k];
//     printf("%f ", val);
    }
//    printf(")  ");
   }

   double constraintEval = cSamples[j]["Constraint Evaluation"];
//   if (constraintEval <  0) printf("Not Pass\n");
//   if (constraintEval >= 0) printf("Pass: ");
   if (constraintEval < 0) cSamples.erase(cSamples.begin() + j);
  }

  std::vector<korali::Sample> eSamples(cSamples.size());
  for (int i = 0; i < eSamples.size(); i++)
  {
   eSamples[i]["Operation"]  = "Evaluate Cost Function";
   eSamples[i]["Variables"] = cSamples[i]["Policy"][currentDepth];
   eSamples[i]["Policy"] = cSamples[i]["Policy"];
   eSamples[i]["Previous Evaluation"]  = cSamples[i]["Previous Evaluation"];
   korali::_conduit->start(eSamples[i]);
  }
  korali::_conduit->waitAll(eSamples);

  double minCostEvaluation = korali::Inf;
  auto bestPolicy = cSamples[0]["Policy"];

  for (int j = eSamples.size()-1; j >= 0; j--)
  {
   for (size_t p = 0; p <= currentDepth; p++)
    for (size_t k = 0; k < varCount; k++)
     double val = cSamples[j]["Policy"][p][k];

   double currEval = eSamples[j]["Cost Evaluation"];
   double prevEval = eSamples[j]["Previous Evaluation"];
   double sumEval = currEval + prevEval;

   if (sumEval < minCostEvaluation)
   {
    bestPolicy = eSamples[j]["Policy"];
    minCostEvaluation = sumEval;
   }
  }


//  printf("Best: ");
//  for (size_t p = 0; p <= currentDepth; p++)
//  {
//   printf("( ");
//   for (size_t k = 0; k < varCount; k++)
//   {
//    double val = bestPolicy[p][k];
//    printf("%f ", val);
//   }
//   printf(") " );
//  }
//
//  printf("Best Policy Val: %f\n", minCostEvaluation);

  if (minCostEvaluation < korali::Inf)
  {
   for (size_t p = 0; p <= currentDepth; p++)
   {
     auto newEntry = bestPolicy[p];
    _newPolicyCollection[p].push_back(newEntry);
   }

   _newPolicyEvaluations.push_back(minCostEvaluation);
  }
 }


 _policyCollection = _newPolicyCollection;
 _policyEvaluation = _newPolicyEvaluations;

 for (size_t i = 0; i < _policyCollection[0].size(); i++)
  for (size_t p = 0; p <= currentDepth; p++)
   for (size_t k = 0; k < varCount; k++)
    _k->_js["Results"]["Optimal Policies"][i][p][k] = _policyCollection[p][i][k];

 _k->_js["Results"]["Policy Evaluations"] = _policyEvaluation;

 double bestEval = korali::Inf;
 size_t bestEvalIdx = -1;
 for (size_t i = 0; i < _policyEvaluation.size(); i++) if (_policyEvaluation[i] < bestEval) { bestEval = _policyEvaluation[i]; bestEvalIdx = i; }
 _k->_js["Results"]["Best Policy Index"] = bestEvalIdx;
}

void korali::solver::Interpolator::printGenerationBefore()
{
}

void korali::solver::Interpolator::printGenerationAfter()
{
}
