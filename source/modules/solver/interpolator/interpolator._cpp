#include "modules/solver/interpolator/interpolator.hpp"
#include "modules/conduit/conduit.hpp"

void korali::solver::Interpolator::setInitialConfiguration()
{
 // Initialize by populating the initial possibility space
 size_t policyCount = 1;
 size_t policyDepth = _k->_currentGeneration;
 size_t varCount = _k->_variables.size();

 _policyCollection.resize(_recursionDepth);

 for (size_t i = 0; i < _k->_variables.size(); i++) policyCount *= (_k->_variables[i]->_intervalCount+1);

 _policyCollection[0].resize(policyCount * varCount);

 printf("Combination Count: %lu, Var Count: %lu\n", policyCount, varCount);
 size_t currentStride = 1;

 for (int i = _k->_variables.size()-1; i >= 0; i--)
 {
  double intervalLength = (_k->_variables[i]->_upperBound + _k->_variables[i]->_lowerBound) / (double)_k->_variables[i]->_intervalCount;

  size_t currentPolicy = 0;
  while (currentPolicy < policyCount)
  for (size_t j = 0; j < _k->_variables[i]->_intervalCount+1; j++)
  {
   double point = (double)j * intervalLength;
   for (size_t k = 0; k < currentStride; k++)
   {
    _policyCollection[0][currentPolicy*varCount + i] = point;
    currentPolicy++;
   }
  }

  currentStride *= (_k->_variables[i]->_intervalCount+1);
 }

 // Evaluating Constraints
 std::vector<korali::Sample> cSamples(policyCount);
 std::vector<double> sampleData(_k->_variables.size());
 for (size_t i = 0; i < policyCount; i++)
 {
  for(size_t j = 0; j < varCount; j++) sampleData[j] = _policyCollection[0][i*varCount + j];
  cSamples[i]["Operation"]  = "Evaluate Constraints";
  cSamples[i]["Policy"][0] = sampleData;
  korali::_conduit->start(cSamples[i]);
 }

 korali::_conduit->waitAll(cSamples);

 // Pruning policies based on constraints
 for (int i = policyCount-1; i >= 0; i--)
 {
  double constraintEval = cSamples[i]["Constraint Evaluation"];
  if (constraintEval < 0)
   {
     printf("i: %lu, Constraint Eval: %f\n", i, constraintEval);
     _policyCollection[0].erase(_policyCollection[0].begin() + i);
     policyCount--;
   }
 }

 std::vector<korali::Sample> eSamples(policyCount);
 for (size_t i = 0; i < policyCount; i++)
 {
  for(size_t j = 0; j < varCount; j++) sampleData[j] = _policyCollection[0][i*varCount + j];
  eSamples[i]["Operation"]  = "Evaluate Cost Function";
  eSamples[i]["Variables"] = sampleData;
  korali::_conduit->start(eSamples[i]);
 }

 korali::_conduit->waitAll(eSamples);

 _policyEvaluation.resize(policyCount);
 for (size_t i = 0; i < policyCount; i++)
 {
  double eval = eSamples[i]["Cost Evaluation"];
  _policyEvaluation[i] = eval;
 }

}

void korali::solver::Interpolator::runGeneration()
{

 if (_k->_currentGeneration == 1) { setInitialConfiguration(); return; }

 size_t currentDepth = _k->_currentGeneration-1;
 size_t policyCount = _policyCollection[currentDepth-1].size();
 size_t varCount = _k->_variables.size();

 _policyCollection[currentDepth].resize(policyCount * varCount);

 size_t candidateCount = 1;
 for (size_t i = 0; i < _k->_variables.size(); i++) candidateCount *= (_k->_variables[i]->_intervalCount+1);
 std::vector<double> candidateList(candidateCount * varCount);

 size_t currentStride = 1;
 for (int i = _k->_variables.size()-1; i >= 0; i--)
 {
  double intervalLength = (_k->_variables[i]->_upperBound + _k->_variables[i]->_lowerBound) / (double)_k->_variables[i]->_intervalCount;

  size_t currentCandidate = 0;
  while (currentCandidate < candidateCount)
  for (size_t j = 0; j < _k->_variables[i]->_intervalCount+1; j++)
  {
   double point = (double)j * intervalLength;
   for (size_t k = 0; k < currentStride; k++)
   {
    candidateList[currentCandidate*varCount + i] = point;
    currentCandidate++;
   }
  }

  currentStride *= (_k->_variables[i]->_intervalCount+1);
 }

 printf("Candidate List Size: %lu\n", candidateList.size());

 for (size_t i = 0; i < policyCount; i++)
 {
  std::vector<korali::Sample> cSamples(candidateList.size());
  size_t currentSample = 0;

  for (size_t j = 0; j < candidateList.size(); j++)
  {
   for (size_t k = 0; k < varCount; k++) _policyCollection[currentDepth][i*varCount + k] = candidateList[j*varCount + k];

   for (size_t p = 0; p <= currentDepth; p++)
   {
    std::vector<double> coordinate(varCount);
    for (size_t k = 0; k < varCount; k++)  coordinate[k] = _policyCollection[p][i*varCount + k];
    cSamples[currentSample]["Policy"][p] = coordinate;
   }

   cSamples[currentSample]["Previous Evaluation"] = _policyEvaluation[i];
   cSamples[currentSample]["Operation"]  = "Evaluate Constraints";
   korali::_conduit->start(cSamples[currentSample]);
   currentSample++;
  }

  korali::_conduit->waitAll(cSamples);

  for (int j = candidateList.size()-1; j >= 0 ; j--)
  {
//   printf("Tried: ");
   for (size_t p = 0; p <= currentDepth; p++)
   {
//    printf("( ");
    for (size_t k = 0; k < varCount; k++)
    {
     double val = cSamples[j]["Policy"][p][k];
//     printf("%f ", val);
    }
//    printf(")  ");
   }

   double constraintEval = cSamples[j]["Constraint Evaluation"];
//   if (constraintEval <  0) printf("Not Pass\n");
//   if (constraintEval >= 0) printf("Pass: ");
   if (constraintEval < 0) cSamples.erase(cSamples.begin() + j);
  }

  printf("Size: %lu\n", cSamples.size());
  std::vector<korali::Sample> eSamples(cSamples.size());
  for (int i = 0; i < eSamples.size(); i++)
  {
   eSamples[i]["Operation"]  = "Evaluate Cost Function";
   eSamples[i]["Variables"] = cSamples[i]["Policy"][currentDepth];
   korali::_conduit->start(eSamples[i]);
  }
  korali::_conduit->waitAll(eSamples);

  double minCostEvaluation = korali::Inf;

  for (int j = eSamples.size()-1; j >= 0 ; j--)
  {
   printf("Tried: ");
   for (size_t p = 0; p <= currentDepth; p++)
   {
    printf("( ");
    for (size_t k = 0; k < varCount; k++)
    {
     double val = cSamples[j]["Policy"][p][k];
     printf("%f ", val);
    }
    printf(")  ");
   }

   double currEval = eSamples[j]["Cost Evaluation"];
   double prevEval = cSamples[j]["Previous Evaluation"];
   double sumEval = currEval + prevEval;

   if (sumEval < minCostEvaluation) minCostEvaluation = sumEval;
   printf("Eval: %f\n", sumEval);
  }

  printf("Best Policy Val: %f\n", minCostEvaluation);
  printf("Feasible Count: %d\n", cSamples.size());
 }


//  _sampleCount   = _k->_variables[0]->_precomputedValues.size();
//
//  _maxModelEvaluations     = std::min(_maxModelEvaluations, _sampleCount);
//  _executionsPerGeneration = std::min(_executionsPerGeneration, _maxModelEvaluations - _modelEvaluationCount);
//
//  std::vector<double> sampleData(_k->_variables.size());
//  std::vector<korali::Sample> samples(_executionsPerGeneration);
//  for (size_t j = 0; j < _k->_variables.size(); j++) sampleData[j] = _k->_variables[j]->_precomputedValues[_modelEvaluationCount];
//
//  for (size_t i = 0; i < _executionsPerGeneration; i++)
//  {
//    std::vector<double> sampleData(_k->_variables.size());
//    for (size_t j = 0; j < _k->_variables.size(); j++) sampleData[j] = _k->_variables[j]->_precomputedValues[_modelEvaluationCount];
//
//    korali::logInfo("Detailed", "Running sample %zu with values:\n         ", _modelEvaluationCount);
//    for(auto& x : sampleData) korali::logData("Detailed", " %le   ", x);
//    korali::logData("Detailed", "\n");
//
//    samples[i]["Operation"]  = "Execute";
//    samples[i]["Parameters"] = sampleData;
//    samples[i]["Sample Id"]  = _modelEvaluationCount;
//    korali::_conduit->start(samples[i]);
//    _modelEvaluationCount++;
//  }
//
//  korali::_conduit->waitAll(samples);
}

void korali::solver::Interpolator::printGenerationBefore()
{
}

void korali::solver::Interpolator::printGenerationAfter()
{
}
