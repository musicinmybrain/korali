#include "modules/solver/learner/learner.hpp"
#include "modules/conduit/conduit.hpp"

void korali::solver::Learner::runGeneration()
{
 if (_k->_currentGeneration == 1)
 {
   _problem = dynamic_cast<korali::problem::ReinforcementLearning*>(_k->_problem);
   setInitialConfiguration();
 }

 // Instructing Learner to initialize generation configuration
 initializeGeneration();

 // Initializing the agents and their environments
 korali::Sample agent;

 agent["Worker"] = 0;
 agent["Sample Id"] = 0;
 agent["Module"] = "Problem";
 agent["Operation"] = "Run Environment";

 _conduit->start(agent);
 _conduit->wait(agent);

 std::vector<double> action(_problem->_actionVectorSize);

 // Variable to store the reward
 double reward;

 // Storage for the entire history of the current policy
 std::vector<std::vector<double>> currentPolicyActions;
 std::vector<std::vector<double>> currentPolicyStates;

 // Storing agent's initial state
 std::vector<double> state = agent["State"];

 while (agent["Finished"] == false)
 {
  // Getting new action to perform
  action = getAction(state);
  agent["Action"] = action;

  // Add state/action to current policy history
  currentPolicyActions.push_back(action);
  currentPolicyStates.push_back(state);

  // Running a new episode
  _conduit->start(agent);
  _conduit->wait(agent);

  // Storing agent's new state
  std::vector<double> newState = agent["State"];

  // Storing agent's reward for the given (s,a)
  reward = agent["Reward"];

  // Storing the agent's experience into the learner
  storeExperience(state, action, reward, newState);

  // The new state becomes the current state
  state = newState;
 }

 if (reward > _bestReward)
 {
  _bestReward = reward;

  currentPolicyStates.push_back(state);

  _bestPolicyStates = currentPolicyStates;
  _bestPolicyActions = currentPolicyActions;

  _k->_js["Results"]["Optimal Policy Actions"] = _bestPolicyActions;
  _k->_js["Results"]["Optimal Policy States"] = _bestPolicyStates;
  _k->_js["Results"]["Optimal Reward"] = _bestReward;
 }

 // Instructing Learner to process finsihed generation
 processGeneration();
}



