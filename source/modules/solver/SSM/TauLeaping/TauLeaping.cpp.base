#include "modules/solver/SSM/TauLeaping/TauLeaping.hpp"

__startNamespace__;

void __className__::advance()
{
  _propensities.resize(_problem->_reactions.size());

  double a0 = 0.0;

  // Calculate propensities
  for (size_t k = 0; k < _problem->_reactions.size(); ++k)
  {
    double a = _problem->computePropensity(k, _numReactants);

    a0 += a;
    _propensities[k] = a;
  }

  // Mark critical reactions
  bool allReactionsAreCritical = true;
  _isCriticalReaction.resize(_problem->_reactions.size());

  for (size_t k = 0; k < _problem->_reactions.size(); ++k)
  {
    const double a = _propensities[k];
    const double L = _problem->calculateMaximumAllowedFirings(k, _numReactants);

    const bool isCritical = !((a > 0) && (L <= _nc));
    _isCriticalReaction[k] = isCritical;

    allReactionsAreCritical = allReactionsAreCritical && isCritical;
  }

  // Estimate maximum tau
  const double tauP = allReactionsAreCritical ? std::numeric_limits<double>::infinity() : estimateLargestTau();


  // Accept or reject step
  if (tauP <  _acceptanceFactor / a0)
  {
        // reject, execute SSA.
        reset(_numReactants, _time);

        for (int i = 0; i < _numStepsSSA; ++i)
        {
            //TODO
            //_ssa.advance();
            //if (_ssa.getTime() >= tend_)
            //    break;
        }

        // TODO
        //_time = _ssa.getTime();
        //const auto newState = ssa_.getState();
        //std::copy(newState.begin(), newState.end(), numSpecies_.begin());
    }
    else
    {
        // TODO
    }
}

double __className__::estimateLargestTau() const
{
    // TODO
    return 0.;
}

__moduleAutoCode__;

__endNamespace__;
