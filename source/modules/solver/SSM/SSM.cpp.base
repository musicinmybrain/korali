#include "modules/solver/SSM/SSM.hpp"

__startNamespace__;


void __className__::initialize()
{
    _variableCount = _k->_variables.size();
    _problem = dynamic_cast<problem::Reaction *>(_k->_problem);
    _binCounter = std::vector<std::vector<int>>(_maxNumSimulations,std::vector<int>(_diagnosticsNumBins, 0));
    _binnedTrajectories = std::vector<std::vector<std::vector<int>>>(_variableCount, std::vector<std::vector<int>>(_maxNumSimulations,std::vector<int>(_diagnosticsNumBins, 0)));
}

void __className__::reset(std::vector<int> numReactants, double time)
{
    _time = time;
    _numReactants = std::move(numReactants);
}

void __className__::updateBins()
{
    size_t binIndex = _time * _simulationLength / (double) _diagnosticsNumBins;
    for(size_t k = 0; k < _variableCount; k++)
    {
        _binCounter[_k->_currentGeneration-1][binIndex] += 1;
        _binnedTrajectories[k][_k->_currentGeneration-1][binIndex] += _numReactants[k];
    }
}


void __className__::runGeneration()
{
  if (_k->_currentGeneration == 1) setInitialConfiguration();

  reset(_problem->_initialReactantNumbers);
  updateBins();

  while (_time < _simulationLength)
  {
    //for (auto& d : diagnostics_)
        //d->collect(i, solver_->getTime(), solver_->getState());
    advance();
    updateBins();
  }

}

void __className__::printGenerationBefore() 
{ 
    // TODO
}

void __className__::printGenerationAfter()
{
    // TODO
}

void __className__::finalize()
{
    //TODO
    std::vector<std::vector<double>> resultsMeanTrajectory(_variableCount, std::vector<double>(_diagnosticsNumBins, 0.));
    for(size_t k = 0; k < _variableCount; k++)
    {
        for(size_t idx = 0; idx < _diagnosticsNumBins; ++idx)
        {
            for(size_t sim = 0; sim < _maxNumSimulations; ++sim) if (_binCounter[sim][idx] > 0)
                resultsMeanTrajectory[k][idx] += _binnedTrajectories[k][sim][idx] / _binCounter[sim][idx];
            resultsMeanTrajectory[k][idx] /= _maxNumSimulations;
        }
    }

}


__moduleAutoCode__;

__endNamespace__;
