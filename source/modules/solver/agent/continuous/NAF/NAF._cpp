#include "engine.hpp"
#include "modules/solver/agent/continuous/NAF/NAF.hpp"
#include "sample/sample.hpp"

namespace korali
{
namespace solver
{
namespace agent
{
namespace continuous
{
void NAF::initializeAgent()
{
  // Initializing common continuous agent configuration
  Continuous::initializeAgent();

  /*********************************************************************
  * Initializing Normal Distributions for the Policy
  *********************************************************************/

  korali::Engine engine; // Engine to initialize experiments with
  _averageActionSigmas.resize(_problem->_actionVectorSize);

  //size_t sigIdx = 0.0;
  for (size_t i = 0; i < _problem->_actionVectorSize; i++)
  {
    auto varIdx = _problem->_actionVectorIndexes[i];
    float sigma = _k->_variables[varIdx]->_explorationSigma;
    if (sigma <= 0.0) KORALI_LOG_ERROR("Value of Noise Sigma (%f) for action variable %lu is not defined or invalid.\n", sigma, i);

    knlohmann::json js;
    js["Type"] = "Univariate/Normal";
    js["Mean"] = 0.0;
    js["Standard Deviation"] = 1.0;

    auto d = dynamic_cast<distribution::univariate::Normal *>(getModule(js, _k));
    _policyDistributions.push_back(d);
  }

  /*********************************************************************
 * Initializing Q(a,s) = A(a,s) + V(s)
 *********************************************************************/

  _qExperiment["Problem"]["Type"] = "Supervised Learning";
  _qExperiment["Solver"]["Type"] = "Learner/DeepSupervisor";
  _qExperiment["Solver"]["Optimizer"] = _criticOptimizer;
  _qExperiment["Solver"]["Learning Rate"] = _criticLearningRate;
  _qExperiment["Solver"]["Loss Function"] = "Direct Gradient";
  _qExperiment["Solver"]["Steps Per Generation"] = 1;
  _qExperiment["Solver"]["Neural Network"] = _criticNeuralNetwork;

  // Initializing experiment with an initial zero set
  for (size_t i = 0; i < _criticMiniBatchSize; i++)
  {
    for (size_t j = 0; j < _problem->_stateVectorSize; j++) _qExperiment["Problem"]["Inputs"][i][j] = 0.0;
    for (size_t j = 0; j < 1 + 2 * _problem->_actionVectorSize; j++) _qExperiment["Problem"]["Solution"][i][j] = 0.0;
  }

  // Running initialization to verify that the configuration is correct
  engine.initialize(_qExperiment);

  // Getting learner pointers
  _qProblem = dynamic_cast<problem::SupervisedLearning *>(_qExperiment._problem);
  _qLearner = dynamic_cast<solver::learner::DeepSupervisor *>(_qExperiment._solver);

  /*********************************************************************
 * Initializing Critic
 *********************************************************************/

  _criticExperiment["Problem"]["Type"] = "Supervised Learning";
  _criticExperiment["Solver"]["Type"] = "Learner/DeepSupervisor";
  _criticExperiment["Solver"]["Optimizer"] = _criticOptimizer;
  _criticExperiment["Solver"]["Learning Rate"] = _criticLearningRate;
  _criticExperiment["Solver"]["Loss Function"] = "Mean Squared Error";
  _criticExperiment["Solver"]["Steps Per Generation"] = 1;
  _criticExperiment["Solver"]["Neural Network"] = _criticNeuralNetwork;

  // Initializing experiment with an initial zero set
  for (size_t j = 0; j < _problem->_stateVectorSize; j++) _criticExperiment["Problem"]["Inputs"][0][j] = 0.0;
  for (size_t j = 0; j < 1 + 2 * _problem->_actionVectorSize; j++) _criticExperiment["Problem"]["Solution"][0][j] = 0.0;

  // Running initialization to verify that the configuration is correct
  engine.initialize(_criticExperiment);

  // Getting learner pointers
  _criticProblem = dynamic_cast<problem::SupervisedLearning *>(_criticExperiment._problem);
  _criticLearner = dynamic_cast<solver::learner::DeepSupervisor *>(_criticExperiment._solver);

  /*********************************************************************
  * Loading/Setting Hyperparameters
  *********************************************************************/

  // Setting Initial Hyperparameters
  _hyperparameters["Critic"] = _qLearner->getHyperparameters();
  _qHatHyperparameter = _qLearner->getHyperparameters();
  _criticLearner->setHyperparameters(_qLearner->getHyperparameters());
  auto blobinit = _qLearner->getHyperparameters();
}

void NAF::trainAgent()
{
  /***********************************************************************************
   * Training Phase
   **********************************************************************************/

  // Calculating cumulative Q*, for statistical purposes
  _cumulativeQStar = 0.0;
  _cumulativeQStarSquared = 0.0;
  std::fill(_averageActionSigmas.begin(), _averageActionSigmas.end(), 0.0);

  // Creating minibatch for the critic update
  auto miniBatchIndexes = generateMiniBatch(_criticMiniBatchSize);
  auto importanceWeights = calculateImportanceWeights(miniBatchIndexes);

  // Reevaluating minibatch with Qhat
  for (size_t i = 0; i < _criticMiniBatchSize; i++)
  {
    // Selecting a uniformly random selected, yet not repeated experience
    size_t expId = miniBatchIndexes[i];

    // Access experiences
    auto curState = _experienceReplayStates[expId];
    auto curAction = _experienceReplayActions[expId];
    float yHat = _experienceReplayRewards[expId];

    // Evaluate Q
    auto qEvaluation = _qLearner->getEvaluation(curState);

    // Transforming NN output to receive mu and diagonal of P
    for (size_t j = 0; j < _problem->_actionVectorSize; j++)
    {
      // mapping mean to [lowerbound - width/2, upperbound + width/2]
      qEvaluation[1 + j] = _actionScalings[j] * (tanh(qEvaluation[1 + j]) + 0.5) + _actionLowerBounds[j];
      qEvaluation[1 + curAction.size() + j] = 0.5 * _actionScalings[j] * exp(2 * tanh(qEvaluation[1 + curAction.size() + j]));
    }

    // yHat* = r -- If terminal state
    // yHat* = r + gamma*V(s) -- If not terminal state

    // If state is not terminal (next state is filled) then add Qnew to the Q value.
    if (_experienceReplayTerminal[expId] == false)
    {
      // Getting experience's next state
      auto nextState = _experienceReplayStates[expId + 1];

      // Calculate target y
      float vHat = _criticLearner->getEvaluation(nextState)[0];
      yHat += _criticDiscountFactor * vHat;
    }

    float qval = quadraticAdvantageFunction(curAction, qEvaluation) + qEvaluation[0]; // A(s,a) + V(s)
    float diff = yHat - qval;

    // Update experience priority
    updateExperienceReplayPriority(expId, abs(diff));

    std::vector<float> policyGradient(1 + 2 * _problem->_actionVectorSize);

    // Fetch importance weight
    float weight = importanceWeights[i];

    // Calculating Gradients of Loss Li wrt. V(s)
    policyGradient[0] = -weight * diff;

    // Calculating Gradients of Li wrt. mu(s) and P(s)
    // We include the gradients of the mappings to mu and P
    for (size_t j = 0; j < curAction.size(); j++)
    {
      float mu = _actionScalings[j] * (tanh(qEvaluation[1 + j]) + 0.5) + _actionLowerBounds[j];
      float diagP = qEvaluation[1 + curAction.size() + j];
      float dmu = curAction[j] - mu;
      float tanhv = log(2.0 / _actionScalings[j] * diagP);                                                       // back transformation ( diagP=1/2scaling*exp(2*tanh(v))
      float tanhm = (mu - _actionLowerBounds[j]) / _actionScalings[j] - 0.5;                                     // back transformation ( mu=scaling*(tanh(m)+1/2)+lowerbound
      policyGradient[1 + j] = -weight * diff * dmu * diagP * _actionScalings[j] * (1 - tanhm * tanhm);           // dLi/dmu
      policyGradient[1 + curAction.size() + j] = weight * 0.5 * diff * dmu * dmu * diagP * (1. - tanhv * tanhv); // dLi/dP(s)
    }

    _qProblem->_inputs[i] = curState;
    _qProblem->_solution[i] = policyGradient;

    // Keeping statistics
    _cumulativeQStar += yHat;
    _cumulativeQStarSquared += yHat * yHat;
    for (size_t j = 0; j < curAction.size(); j++) _averageActionSigmas[j] += sqrt(qEvaluation[1 + curAction.size() + j]);
  }

  // Running one generation of the optimization method with the given mini-batch
  _qLearner->initialize();
  _qLearner->runGeneration();
  _qLearner->finalize();

  // Keeping statistics
  _averageQStar = (float)_cumulativeQStar / (float)_criticMiniBatchSize;
  _stdevQStar = sqrt(_cumulativeQStarSquared / (float)_criticMiniBatchSize - _averageQStar * _averageQStar);
  for (size_t j = 0; j < _averageActionSigmas.size(); j++) _averageActionSigmas[j] /= (float)_criticMiniBatchSize;

  /*********************************************************************
   * Updating hyperparameters and broadcasting them to the workers
   *********************************************************************/

  auto qHyperparam = _qLearner->getHyperparameters();

  // Update the target network
  for (size_t i = 0; i < qHyperparam.size(); ++i)
  {
    _qHatHyperparameter[i] = _targetLearningRate * qHyperparam[i] + (1. - _targetLearningRate) * _qHatHyperparameter[i];
  }
  _criticLearner->setHyperparameters(_qHatHyperparameter);

  // Storing new Critics' hyperparameters
  _hyperparameters["Critic"] = qHyperparam;
}

void NAF::updateHyperparameters(const knlohmann::json &hyperparameters)
{
  _qLearner->setHyperparameters(hyperparameters["Critic"].get<std::vector<float>>());
}

void NAF::forwardPolicy(const std::vector<float> &state)
{
  auto qNNoutput = _qLearner->getEvaluation(state);

  // Transforming NN output to receive mu and diagonal of P
  for (size_t i = 0; i < _actionMeans.size(); ++i)
  {
    // mapping mean to [lowerbound - width/2, upperbound + width/2]
    _actionMeans[i] = _actionScalings[i] * (tanh(qNNoutput[1 + i]) + 0.5) + _actionLowerBounds[i];
    _actionSigmas[i] = sqrt(0.5 * _actionScalings[i]) * exp(-tanh(qNNoutput[i + 1 + _actionMeans.size()]));
  }
}

float NAF::quadraticAdvantageFunction(const std::vector<float> &action, const std::vector<float> &qEvaluation)
{
  float qval = 0;
  for (size_t i = 0; i < action.size(); ++i)
  {
    float dmu = (action[i] - qEvaluation[i + 1]);
    float diagP = qEvaluation[i + 1 + action.size()];
    qval += dmu * diagP * dmu;
  }
  return -0.5 * qval;
}

void NAF::printAgentInformation()
{
  _k->_logger->logInfo("Normal", "Critic Information:\n");
  _k->_logger->logInfo("Normal", " + Average (Std) Q-Value in Mini-Batch:  %f (%f)\n", _averageQStar, _stdevQStar);
  _k->_logger->logInfo("Normal", " + Average P values in Mini-Batch: \n");
  for (size_t i = 0; i < _averageActionSigmas.size(); ++i) _k->_logger->logInfo("Normal", " +  [ %f ]\n", _averageActionSigmas[i]);

  _qExperiment._logger->_verbosityLevel = _k->_logger->_verbosityLevel;
  _qExperiment._solver->printGenerationAfter();
  _qExperiment._logger->setVerbosityLevel("Silent");
}

} // namespace continuous
} // namespace agent
} // namespace solver
} // namespace korali
