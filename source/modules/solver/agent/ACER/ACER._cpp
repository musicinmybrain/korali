#include "engine.hpp"
#include "modules/solver/agent/ACER/ACER.hpp"
#include "sample/sample.hpp"

/****************************************
 * Things to fix:
 * - All samples use their own pseudorandom generators
 * - All seeds must be replicable when restarting a job
 *****************************************/

namespace korali
{
namespace solver
{
namespace agent
{

void ACER::trainAgent()
{
  // Creating storage for the starting index for all current trajectories
  std::vector<size_t> trajectoryStartIndexes;

  // Detecting trajectories
  for (size_t i = 0; i < _experienceReplayHistory.size(); i++)
   if (_experienceReplayHistory[i]["Trajectory Position"] == 0)
    trajectoryStartIndexes.push_back(i);

  // Storage for trajectory selections
  std::vector<size_t> trajectories;

  // Adding on-policy trajectory first
  trajectories.push_back(trajectoryStartIndexes[trajectoryStartIndexes.size()-1]);

  // Shuffling indexes to choose the off-policy trajectories from
  std::shuffle(trajectoryStartIndexes.begin(), trajectoryStartIndexes.end()-1, *mt);

  // Adding off-policy trajectories
  for (size_t i = 0; i < _offPolicyUpdates; i++) trajectories.push_back(trajectoryStartIndexes[i]);

  for (size_t tId = 0; tId < trajectories.size(); tId++)
  {
   // Getting initial experience id from the trajectory
   size_t startId = trajectories[tId];

   // Looking for final experience id from the trajectory
   size_t endId = startId;
   while (_experienceReplayHistory[endId]["Trajectory End"] == false) endId++;

   // Training from the selected trajectory
   processTrajectory(startId, endId);
  }
}

} // namespace agent

} // namespace solver

} // namespace korali
