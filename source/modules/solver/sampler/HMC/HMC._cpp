#include "modules/conduit/conduit.hpp"
#include "modules/experiment/experiment.hpp"
#include "modules/problem/problem.hpp"
#include "modules/solver/sampler/HMC/HMC.hpp"

#include <chrono>
#include <limits>
#include <numeric>

#include <gsl/gsl_linalg.h>
#include <gsl/gsl_matrix.h>
#include <gsl/gsl_multimin.h>
#include <gsl/gsl_sort_vector.h>
#include <gsl/gsl_statistics.h>

namespace korali
{
namespace solver
{
namespace sampler
{
void HMC::setInitialConfiguration()
{
  if (!(_version == "Static" || _version == "Euclidean" || _version == "Riemannian" || _version == "Riemannian Const")) KORALI_LOG_ERROR("Version must be either 'Static', 'Euclidean' or 'Riemannian' (is %s)\n", _version.c_str());
  // TODO: Check exact intervals (i.e. inclusion and exclusion)
  if (!(_burnIn >= 0)) KORALI_LOG_ERROR("Burn In must be larger equal 0 (is %zu).\n", _burnIn);
  if (!(_metricEstimateQuotient > 0.0 && _metricEstimateQuotient <= 1.0)) KORALI_LOG_ERROR("Metric Estimate Quotient must be in interval (0.0, 1.0] (is %lf).\n", _metricEstimateQuotient);
  if (!(_maxDepth >= 0)) KORALI_LOG_ERROR("Max Depth must be non-negative. (is %zu).\n", _maxDepth);

  // Check Adaptive Step Size settings
  if (!(_desiredAverageAcceptanceRate > 0.0 && _desiredAverageAcceptanceRate <= 1.0)) KORALI_LOG_ERROR("Desired Average Acceptance Rate must be in interval (0.0, 1.0] (is %lf).\n", _desiredAverageAcceptanceRate);
  if (!(_targetIntegrationTime >= 0.0)) KORALI_LOG_ERROR("Target Integration Time must be non-negative (is %lf).\n", _targetIntegrationTime);
  if (!(_numIntegrationSteps > 0)) KORALI_LOG_ERROR("Num Integration Steps must be larger equal 1 (is %zu).\n", _numIntegrationSteps);
  if (!(_maxNumFixedPointIteration > 0)) KORALI_LOG_ERROR("Max Num Fixed Point Iterations must be larger equal 1 (is %zu).\n", _maxNumFixedPointIteration);
  if (!(_adaptiveStepSizeSpeedConstant > 0.0)) KORALI_LOG_ERROR("Adaptive Step Size Speed Constant must be positive (is %lf).\n", _adaptiveStepSizeSpeedConstant);
  if (!(_adaptiveStepSizeStabilizationConstant >= 0.0)) KORALI_LOG_ERROR("Adaptive Step Size Stabilization Constant must be non-negative (is %lf).\n", _adaptiveStepSizeStabilizationConstant);
  if (!(_adaptiveStepSizeScheduleConstant > 0.5 && _adaptiveStepSizeScheduleConstant <= 1.0)) KORALI_LOG_ERROR("Adaptive Step Size Schedule Constant must be in the interval (0.5, 1.0] (is %lf).\n", _adaptiveStepSizeScheduleConstant);
  if (!(_stepSizeJitter >= 0.0 && _stepSizeJitter <= 1.0)) KORALI_LOG_ERROR("Step Size Jitter has to in [0.0, 1.0] (is %lf).\n", _stepSizeJitter);

  _dimensions = _k->_variables.size();

  // Resizing vectors of internal settings to correct dimensions
  _positionLeader.resize(_dimensions);
  _positionCandidate.resize(_dimensions);
  _momentumLeader.resize(_dimensions);
  _momentumCandidate.resize(_dimensions);
  _positionMean.resize(_dimensions);

  // initializing variable defaults
  for (size_t i = 0; i < _k->_variables.size(); i++)
  {
    if (std::isfinite(_k->_variables[i]->_initialMean) == false)
      KORALI_LOG_ERROR("Initial Mean of variable \'%s\' not defined.\n", _k->_variables[i]->_name.c_str());
    if (std::isfinite(_k->_variables[i]->_initialStandardDeviation) == false)
      KORALI_LOG_ERROR("Initial Standard Deviation of variable \'%s\' not defined.\n", _k->_variables[i]->_name.c_str());
    _positionLeader[i] = _k->_variables[i]->_initialMean;
  }

  // Initializing metric and inverseMetric for diagonal and dense
  std::vector<double> metric;
  std::vector<double> inverseMetric;

  if (_useDiagonalMetric == true || _version == "Static")
  {
    metric.resize(_dimensions);
    inverseMetric.resize(_dimensions);
    for (size_t i = 0; i < _dimensions; ++i)
    {
      metric[i] = _k->_variables[i]->_initialStandardDeviation * _k->_variables[i]->_initialStandardDeviation;
      inverseMetric[i] = 1.0 / metric[i];
    }
  }
  else
  {
    metric.resize(_dimensions * _dimensions, 0.0);
    inverseMetric.resize(_dimensions * _dimensions, 0.0);

    for (size_t d = 0; d < _dimensions; ++d)
    {
      metric[d * _dimensions + d] = _k->_variables[d]->_initialStandardDeviation * _k->_variables[d]->_initialStandardDeviation;
      inverseMetric[d * _dimensions + d] = 1.0 / metric[d * _dimensions + d];
    }
  }

  // Initializing Integrator and Hamiltonian
  if (_version == "Static")
  {
    _integrator = new LeapfrogExplicit;
    _hamiltonian = new HamiltonianEuclideanDiag{_dimensions, _normalGenerator, metric, inverseMetric};
  }
  else if (_version == "Euclidean")
  {
    _integrator = new LeapfrogExplicit;
    if (_useDiagonalMetric)
      _hamiltonian = new HamiltonianEuclideanDiag{_dimensions, _normalGenerator, metric, inverseMetric};
    else
      _hamiltonian = new HamiltonianEuclideanDense{_dimensions, _multivariateGenerator, metric, inverseMetric};
  }
  else if (_version == "Riemannian")
  {
    _integrator = new LeapfrogImplicit(_maxNumFixedPointIteration);
    if (_useDiagonalMetric)
      _hamiltonian = new HamiltonianRiemannianDiag{_dimensions, _normalGenerator, metric, inverseMetric, _inverseRegularizationParameter};
    else
      KORALI_LOG_ERROR("Riemannian Metric only supported with Diagonal Metric");
  }
  else if (_version == "Riemannian Const")
  {
    _integrator = new LeapfrogExplicit;
    if (_useDiagonalMetric)
      _hamiltonian = new HamiltonianRiemannianConstDiag{_dimensions, _normalGenerator, metric, inverseMetric, _inverseRegularizationParameter};
    else
      _hamiltonian = new HamiltonianRiemannianConstDense{_dimensions, _multivariateGenerator, metric, inverseMetric, _inverseRegularizationParameter};
  }

  _hamiltonian->verbosity = _hamiltonianVerbosity;
  _integrator->verbosity = _integratorVerbosity;

  if (_useAdaptiveStepSize == true)
  {
    _stepSize = findReasonableStepSize(_positionLeader);
    _mu = std::log(10.0 * _stepSize);
    _hBar = 0.0;
  }

  // Initialize Generation
  _acceptanceCount = 0;
  _proposedSampleCount = 0;
  _chainLength = 0;
  _acceptanceRate = 1.0;
}

void HMC::runGeneration()
{
  fflush(stdout);
  if (_k->_currentGeneration == 1) setInitialConfiguration();
  _hamiltonian->updateHamiltonian(_positionLeader, _k);

  // Samples Momentum Candidate from N(0.0, metric)

  _momentumCandidate = _hamiltonian->sampleMomentum();
  ++_proposedSampleCount;

  _positionCandidate = _positionLeader;
  _momentumLeader = _momentumCandidate;

  const double logUniSample = std::log(_uniformGenerator->getRandomNumber());

  if (_version == "Riemannian Const")
  {
    // std::cout << "In Riemannian Const update metric" << std::endl;
    // __printVec(_hamiltonian->getMetric());
    _hamiltonian->updateMetricMatricesRiemannian(_positionLeader, _k);
    // __printVec(_hamiltonian->getMetric());
  }

  if (_useNUTS)
  {
    if (_version == "Euclidean" || _version == "Static")
    {
      TreeHelperEuclidean *helper = new TreeHelperEuclidean;
      helper->logUniSampleIn = logUniSample;
      runGenerationNUTSUtil(helper);
      delete helper;
      // TreeHelperRiemannian *helper = new TreeHelperRiemannian;
      // helper->logUniSampleIn = logUniSample;
      // runGenerationNUTSUtilRiemannian(helper);
      // delete helper;
    }
    else if (_version == "Riemannian")
    {
      // TreeHelperEuclidean *helper = new TreeHelperEuclidean;
      // helper->logUniSampleIn = logUniSample;
      // runGenerationNUTSUtil(helper);
      // delete helper;
      TreeHelperRiemannian *helper = new TreeHelperRiemannian;
      helper->logUniSampleIn = logUniSample;
      runGenerationNUTSUtilRiemannian(helper);
      delete helper;
    }
    else if (_version == "Riemannian Const")
    {
      // std::cout << "runGeneration" << std::endl;
      TreeHelperEuclidean *helper = new TreeHelperEuclidean;
      helper->logUniSampleIn = logUniSample;
      runGenerationNUTSUtil(helper);
      delete helper;
    }
  }
  else
  {
    runGenerationHMC(logUniSample);
  }

  saveSample();

  updateState();

  ++_chainLength;

  return;
}

void HMC::runGenerationHMC(const double logUniSample)
{
  // _hamiltonian->updateHamiltonian(_positionLeader, _k);
  const double oldK = _hamiltonian->K(_momentumLeader);
  const double oldU = _hamiltonian->U();

  if (_useAdaptiveStepSize == true && _chainLength <= _burnIn)
  {
    _numIntegrationSteps = std::max((size_t)1, (size_t)std::round(_targetIntegrationTime / _stepSize));
  }

  // Perform Num Integration Steps of Leapfrog scheme to Momentum Candidate and Position Candidate
  // std::cout << "in front of _integrator->step(...)" << std::endl;
  for (size_t i = 0; i < _numIntegrationSteps; ++i)
  {
    _integrator->step(_positionCandidate, _momentumCandidate, _stepSize, _hamiltonian, _k);
  }
  // std::cout << "after _integrator->step(...)" << std::endl;

  // Negate proposed momentum to make proposal symmetric

  std::transform(std::cbegin(_momentumCandidate), std::cend(_momentumCandidate), std::begin(_momentumCandidate), std::negate<double>());

  // Save new Energies
  // std::cout << "in front of _hamiltonian->updateHamiltonian(...)" << std::endl;
  _hamiltonian->updateHamiltonian(_positionCandidate, _k);
  // std::cout << "after _hamiltonian->updateHamiltonian(...)" << std::endl;
  const double newK = _hamiltonian->K(_momentumCandidate);
  const double newU = _hamiltonian->U();

  const double logAlpha = std::min(0.0, -(newK - oldK + newU - oldU));
  _acceptanceProbability = std::exp(logAlpha);

  if (logUniSample <= logAlpha && isNan(_positionCandidate) == false)
  {
    ++_acceptanceCount;
    _positionLeader = _positionCandidate;
  }

  return;
}

void HMC::runGenerationNUTS(const double logUniSample)
{
  const double oldK = _hamiltonian->K(_momentumLeader);
  const double oldU = _hamiltonian->U();

  std::vector<double> nullPointOne(_dimensions);
  std::vector<double> nullPointTwo(_dimensions);
  std::vector<double> tmpVector(_dimensions, 0.0);

  // std::vector<double> rhoInit = _momentumLeader;
  std::vector<double> rhoPlus(_dimensions, 0.0);
  std::vector<double> rhoMinus(_dimensions, 0.0);

  std::vector<double> qLeft = _positionLeader;
  std::vector<double> qRight = _positionLeader;
  std::vector<double> pLeft = _momentumLeader;
  std::vector<double> pRight = _momentumLeader;

  int depth = 0;
  int numLeavesSubtree;
  bool buildCriterion = true;
  bool buildCriterionSubtree;
  double numValidLeaves = 1.0;
  double numValidLeavesSubtree;
  double dotProductLeft, dotProductRight;
  const double oldH = oldU + oldK;

  while (buildCriterion == true && depth <= _maxDepth)
  {
    // std::vector<double> rho(_dimensions, 0.0);
    if (_uniformGenerator->getRandomNumber() < 0.5)
    {
      buildTree(qLeft, pLeft, logUniSample, -1, depth, _stepSize, oldH, qLeft, pLeft, nullPointOne, nullPointTwo, _positionCandidate, numValidLeavesSubtree, buildCriterionSubtree, _acceptanceProbability, numLeavesSubtree);
    }
    else
    {
      buildTree(qRight, pRight, logUniSample, 1, depth, _stepSize, oldH, nullPointOne, nullPointTwo, qRight, pRight, _positionCandidate, numValidLeavesSubtree, buildCriterionSubtree, _acceptanceProbability, numLeavesSubtree);
    }

    if (buildCriterionSubtree == true)
    {
      if (numValidLeaves == 0)
      {
        KORALI_LOG_ERROR("Division by zero encountered in NUTS (numValidLeaves is %lf).\n", numValidLeaves);
      }
      if (_uniformGenerator->getRandomNumber() < numValidLeavesSubtree / numValidLeaves)
      {
        _positionLeader = _positionCandidate;
      }
    }

    numValidLeaves += numValidLeavesSubtree;

    std::transform(std::cbegin(qRight), std::cend(qRight), std::cbegin(qLeft), std::begin(tmpVector), std::minus<double>());
    dotProductLeft = std::inner_product(std::cbegin(tmpVector), std::cend(tmpVector), std::cbegin(pLeft), 0.0);
    dotProductRight = std::inner_product(std::cbegin(tmpVector), std::cend(tmpVector), std::cbegin(pRight), 0.0);

    buildCriterion = buildCriterionSubtree && (dotProductLeft > 0) && (dotProductRight > 0);

    // std::cout << "depth = " << depth << std::endl;
    // std::cout << "Normal difference: " << std::endl;
    // std::cout << "dotProductLeft = " << dotProductLeft << std::endl;
    // std::cout << "dotProductRight = " << dotProductRight << std::endl;

    // std::vector<double> deltaRho(_dimensions, 0.0);

    // std::transform(std::cbegin(rhoMinus), std::cend(rhoMinus), std::cbegin(deltaRho), std::begin(deltaRho), std::plus<double>());
    // std::transform(cbegin(rhoInit), std::cend(rhoInit), std::cbegin(deltaRho), std::begin(deltaRho), std::plus<double>());
    // std::transform(std::cbegin(rhoPlus), std::cend(rhoPlus), std::cbegin(deltaRho), std::begin(deltaRho), std::plus<double>());

    // for (size_t i = 0; i <_dimensions; ++i)
    // {
    //   deltaRho[i] = _stepSize * rhoInit[i] + rhoMinus[i] + rhoPlus[i];
    //   deltaRho[i] = rhoMinus[i] + rhoPlus[i];
    // }

    // buildCriterion = buildCriterionSubtree && computeNoUTurnCriterion(pLeft, pRight, deltaRho);
    ++depth;
  }

  _acceptanceProbability /= (double)numLeavesSubtree;
  _acceptanceCountNUTS += _acceptanceProbability;

  return;
}

void HMC::runGenerationNUTSUtil(TreeHelperEuclidean *helper)
{
  // _hamiltonian->updateHamiltonian(_positionLeader, _k);
  const double oldK = _hamiltonian->K(_momentumLeader);
  const double oldU = _hamiltonian->U();

  std::vector<double> qLeft = _positionLeader;
  std::vector<double> pLeft = _momentumLeader;
  std::vector<double> qRight = _positionLeader;
  std::vector<double> pRight = _momentumLeader;

  int depth = 0;
  int numLeavesSubtree;
  bool buildCriterion = true;
  bool buildCriterionSubtree;
  double numValidLeaves = 1.0;
  double numValidLeavesSubtree;
  const double oldH = oldU + oldK;

  helper->depthIn = 0;
  helper->rootHIn = oldH;
  helper->buildCriterionOut = true;

  while (buildCriterion == true && depth <= _maxDepth)
  {
    helper->depthIn = depth;
    if (_uniformGenerator->getRandomNumber() < 0.5)
    {
      helper->qIn = qLeft;
      helper->pIn = pLeft;
      helper->directionIn = -1;

      buildTreeUtil(helper);

      qLeft = helper->qLeftOut;
      pLeft = helper->pLeftOut;
      // qRight = --
      // pRight = --

      // Setting for termination criterium
      helper->qRightOut = qRight;
      helper->pRightOut = pRight;
    }
    else
    {
      helper->qIn = qRight;
      helper->pIn = pRight;
      helper->directionIn = 1;

      buildTreeUtil(helper);

      // qLeft = --
      // pLeft = --
      qRight = helper->qRightOut;
      pRight = helper->pRightOut;

      // setting for termination criterium
      helper->qLeftOut = qLeft;
      helper->pLeftOut = pLeft;
    }
    _positionCandidate = helper->qProposedOut;
    numValidLeavesSubtree = helper->numValidLeavesOut;
    buildCriterionSubtree = helper->buildCriterionOut;
    _acceptanceProbability = helper->alphaOut;
    numLeavesSubtree = helper->numLeavesOut;

    if (buildCriterionSubtree == true)
    {
      if (numValidLeaves == 0)
      {
        KORALI_LOG_ERROR("Division by zero encountered in NUTS (numValidLeaves is %lf).\n", numValidLeaves);
      }
      if (_uniformGenerator->getRandomNumber() < numValidLeavesSubtree / numValidLeaves && isNan(_positionCandidate) == false)
      {
        _positionLeader = _positionCandidate;
      }
    }

    numValidLeaves += numValidLeavesSubtree;

    buildCriterion = buildCriterionSubtree && helper->computeCriterion(_hamiltonian);

    ++depth;
  }

  _acceptanceProbability /= (double)numLeavesSubtree;
  _acceptanceCountNUTS += _acceptanceProbability;

  return;
}

void HMC::runGenerationNUTSUtilRiemannian(TreeHelperRiemannian *helper)
{
  // _hamiltonian->updateHamiltonian(_positionLeader, _k);
  const double oldK = _hamiltonian->K(_momentumLeader);
  const double oldU = _hamiltonian->U();

  std::vector<double> qLeft = _positionLeader;
  std::vector<double> pLeft = _momentumLeader;
  std::vector<double> qRight = _positionLeader;
  std::vector<double> pRight = _momentumLeader;

  int depth = 0;
  int numLeavesSubtree;
  bool buildCriterion = true;
  bool buildCriterionSubtree;
  double numValidLeaves = 1.0;
  double numValidLeavesSubtree;
  const double oldH = oldU + oldK;

  helper->depthIn = 0;
  helper->rootHIn = oldH;
  helper->buildCriterionOut = true;

  std::vector<double> tmp(_dimensions, 0.0);
  std::vector<double> rhoInit = _momentumLeader;
  std::vector<double> rhoLeft(_dimensions, 0.0);
  std::vector<double> rhoRight(_dimensions, 0.0);
  while (buildCriterion == true && depth <= _maxDepth)
  {
    helper->depthIn = depth;
    if (_uniformGenerator->getRandomNumber() < 0.5)
    {
      helper->qIn = qLeft;
      helper->pIn = pLeft;
      helper->directionIn = -1;

      buildTreeUtilIntegration(helper, rhoLeft);

      qLeft = helper->qLeftOut;
      pLeft = helper->pLeftOut;
      // qRight = --
      // pRight = --

      // Setting for termination criterium
      helper->qRightOut = qRight;
      helper->pRightOut = pRight;
    }
    else
    {
      helper->qIn = qRight;
      helper->pIn = pRight;
      helper->directionIn = 1;

      buildTreeUtilIntegration(helper, rhoRight);

      // qLeft = --
      // pLeft = --
      qRight = helper->qRightOut;
      pRight = helper->pRightOut;

      // setting for termination criterium
      helper->qLeftOut = qLeft;
      helper->pLeftOut = pLeft;
    }
    _positionCandidate = helper->qProposedOut;
    numValidLeavesSubtree = helper->numValidLeavesOut;
    buildCriterionSubtree = helper->buildCriterionOut;
    _acceptanceProbability = helper->alphaOut;
    numLeavesSubtree = helper->numLeavesOut;

    if (buildCriterionSubtree == true)
    {
      if (numValidLeaves == 0)
      {
        KORALI_LOG_ERROR("Division by zero encountered in NUTS (numValidLeaves is %lf).\n", numValidLeaves);
      }
      if (_uniformGenerator->getRandomNumber() < numValidLeavesSubtree / numValidLeaves && isNan(_positionCandidate) == false)
      {
        _positionLeader = _positionCandidate;
      }
    }

    numValidLeaves += numValidLeavesSubtree;

    std::vector<double> deltaRho(_dimensions, 0.0);

    std::transform(std::cbegin(rhoLeft), std::cend(rhoLeft), std::cbegin(deltaRho), std::begin(deltaRho), std::plus<double>());
    std::transform(cbegin(rhoInit), std::cend(rhoInit), std::cbegin(deltaRho), std::begin(deltaRho), std::plus<double>());
    std::transform(std::cbegin(rhoRight), std::cend(rhoRight), std::cbegin(deltaRho), std::begin(deltaRho), std::plus<double>());

    buildCriterion = buildCriterionSubtree && helper->computeCriterion(_hamiltonian, pLeft, pRight, deltaRho);

    ++depth;
  }

  _acceptanceProbability /= (double)numLeavesSubtree;
  _acceptanceCountNUTS += _acceptanceProbability;

  return;
}

// TODO: Remove
double HMC::dotProduct(const std::vector<double> &pLeft, const std::vector<double> &pRight) const
{
  double tmpScalar = 0.0;

  std::vector<double> inverseMetric = _hamiltonian->getInverseMetric();
  for (size_t i = 0; i < _dimensions; ++i)
  {
    for (size_t j = 0; j < _dimensions; ++j)
    {
      tmpScalar += pLeft[i] * inverseMetric[i * _dimensions + j] * pRight[j];
    }
  }

  return tmpScalar;
}

void HMC::saveSample()
{
  if (_chainLength >= _burnIn)
  {
    _sampleDatabase.push_back(_positionLeader);
  }
  else if (_version == "Euclidean")
  {
    _warmupSampleDatabase.push_back(_positionLeader);
  }

  return;
}

void HMC::updateStepSize()
{
  if (_chainLength + 1 < _burnIn)
  {
    _hBar = (1.0 - 1.0 / (_chainLength + 1 + _adaptiveStepSizeStabilizationConstant)) * _hBar + (_desiredAverageAcceptanceRate - _acceptanceProbability) / (_chainLength + 1 + _adaptiveStepSizeStabilizationConstant);
    _stepSize = std::exp((_mu - std::sqrt(_chainLength + 1) / _adaptiveStepSizeSpeedConstant * _hBar));
    _dualStepSize = std::pow((_stepSize / _dualStepSize), std::pow(_chainLength + 1, -_adaptiveStepSizeScheduleConstant)) * _dualStepSize;
  }
  else if (_chainLength + 1 == _burnIn)
  {
    _stepSize = _dualStepSize;
  }

  return;
}

void HMC::updateState()
{
  _acceptanceRate = _useNUTS == true ? (double)_acceptanceCountNUTS / ((double)_chainLength + 1) : (double)_acceptanceCount / ((double)(_chainLength + 1));

  // std::cout << "in front of _chainlength..." << std::endl;
  _chainLength < _burnIn ? updateStateWarmup() : updateStateSampling();
  // std::cout << "after _chainlength..." << std::endl;

  return;
}

void HMC::updateStateWarmup()
{
  // Update Step Size, Dual Step Size, H Bar for Adaptive Step Size option
  if (_useAdaptiveStepSize == true && _chainLength <= _burnIn)
  {
    updateStepSize();
  }

  // return if no samples available
  if (_warmupSampleDatabase.size() == 0)
  {
    return;
  }

  // for one sample simply set average to current value (to avoid dividing by zero)
  if (_warmupSampleDatabase.size() == 1)
  {
    for (size_t d = 0; d < _dimensions; ++d)
    {
      _positionMean[d] = _positionLeader[d];
    }

    return;
  }

  // calculate chain mean for > 1 sample
  if (_warmupSampleDatabase.size() > 1)
  {
    for (size_t d = 0; d < _dimensions; ++d)
    {
      _positionMean[d] = (_positionMean[d] * (_warmupSampleDatabase.size() - 1) + _positionLeader[d]) / _warmupSampleDatabase.size();
    }
  }

  // case: Use Adaptive Sampling = True
  //       Approximate Inverse Matrix via Fisher Information
  if (_version == "Euclidean" && (int)(_metricEstimateQuotient * (double)_burnIn) == _chainLength + 1)
  {
    int err = _hamiltonian->updateMetricMatricesEuclidean(_warmupSampleDatabase, _positionMean);

    // metric = _hamiltonian->getMetric();
    // inverseMetric = _hamiltonian->getInverseMetric();

    if (err == GSL_EDOM)
    {
      // error handling for non s.p.d. matrices
      _k->_logger->logWarning("Normal", "Inverse Metric negative definite (not updating Metric). Try Increasing Burn In.\n");
    }
  }

  return;
}

void HMC::updateStateSampling()
{
  // Apply Step Size Jitter
  _stepSize = _dualStepSize * (1.0 + _stepSizeJitter * (2.0 * _uniformGenerator->getRandomNumber() - 1.0));

  // return if no samples available
  if (_sampleDatabase.size() == 0)
  {
    return;
  }

  // for one sample simply set average to current value (to avoid dividing by zero)
  if (_sampleDatabase.size() == 1)
  {
    for (size_t d = 0; d < _dimensions; ++d)
    {
      _positionMean[d] = _positionLeader[d];
    }

    return;
  }

  // calculate chain mean for > 1 sample
  if (_sampleDatabase.size() > 1)
  {
    for (size_t d = 0; d < _dimensions; ++d)
    {
      _positionMean[d] = (_positionMean[d] * (_sampleDatabase.size() - 1) + _positionLeader[d]) / _sampleDatabase.size();
    }
  }

  return;
}

void HMC::printGenerationBefore()
{
  return;
}

void HMC::printGenerationAfter()
{
  // Number of Samples
  _k->_logger->logInfo("Minimal", "Database Entries %ld\n", _sampleDatabase.size());

  _useNUTS == true ? _k->_logger->logInfo("Detailed", "Accepted Samples Indicator (NUTS): %lf\n", _acceptanceCountNUTS) : _k->_logger->logInfo("Normal", "Accepted Samples: %zu\n", _acceptanceCount);

  _k->_logger->logInfo("Normal", "Acceptance Rate Proposals: %.2f%%\n", 100 * _acceptanceRate);

  // Current Sample
  _k->_logger->logInfo("Detailed", "Current Sample:\n");
  for (size_t d = 0; d < _dimensions; ++d) _k->_logger->logData("Detailed", "         %s = %+6.3e\n", _k->_variables[d]->_name.c_str(), _positionLeader[d]);
  _k->_logger->logInfo("Detailed", "Current Chain Mean:\n");
  for (size_t d = 0; d < _dimensions; ++d) _k->_logger->logData("Detailed", "         %s = %+6.3e\n", _k->_variables[d]->_name.c_str(), _positionMean[d]);
  _k->_logger->logInfo("Detailed", "Current Metric:\n");

  auto metric = _hamiltonian->getMetric();
  if (_useDiagonalMetric)
  {
    for (size_t d = 0; d < _dimensions; ++d)
    {
      _k->_logger->logData("Detailed", "         %+6.3e  ", metric[d]);
      _k->_logger->logInfo("Detailed", "\n");
    }
  }
  else
  {
    for (size_t d = 0; d < _dimensions; ++d)
    {
      for (size_t e = 0; e < _dimensions; ++e)
      {
        _k->_logger->logData("Detailed", "         %+6.3e  ", metric[d * _dimensions + e]);
      }
      _k->_logger->logInfo("Detailed", "\n");
    }
  }

  // Gradient
  _k->_logger->logInfo("Normal", "Gradient:\n");
  auto grad = _hamiltonian->dU();
  for (auto &g : grad) _k->_logger->logData("Normal", "         %+6.3e  \n", g);

  // Inverse Metric
  _k->_logger->logInfo("Normal", "Current Inverse Metric:\n");

  auto inverseMetric = _hamiltonian->getInverseMetric();
  if (_useDiagonalMetric)
  {
    for (size_t e = 0; e < _dimensions; ++e)
    {
      _k->_logger->logData("Normal", "         %+6.3e  ", inverseMetric[e]);
      _k->_logger->logInfo("Normal", "\n");
    }
  }
  else
  {
    for (size_t d = 0; d < _dimensions; ++d)
    {
      for (size_t e = 0; e < _dimensions; ++e)
      {
        _k->_logger->logData("Normal", "         %+6.3e  ", inverseMetric[d * _dimensions + e]);
      }
      _k->_logger->logInfo("Normal", "\n");
    }
  }

  // Chain Length + 1 = m in Algorithm
  _k->_logger->logInfo("Detailed", "Chain Length: %ld\n", _chainLength);

  if (_useAdaptiveStepSize == true)
  {
    // Step Size
    _k->_logger->logInfo("Detailed", "Step Size: %lf\n", _stepSize);
    // Dual Step Size
    _k->_logger->logInfo("Detailed", "Dual Step Size: %lf\n", _dualStepSize);

    if (_useNUTS == false)
    {
      // Num Integration Steps
      _k->_logger->logInfo("Detailed", "Num Integration Steps: %ld\n", _numIntegrationSteps);
    }

    // Dual Step Size
    _k->_logger->logInfo("Detailed", "H Bar: %lf\n", _hBar);
  }

  return;
}

void HMC::finalize()
{
  _k->_logger->logInfo("Minimal", "Number of Generated Samples: %zu\n", _proposedSampleCount);
  _k->_logger->logInfo("Minimal", "Acceptance Rate: %.2f%%\n", 100 * _acceptanceRate);
  if (_sampleDatabase.size() == _maxSamples) _k->_logger->logInfo("Minimal", "Max Samples Reached.\n");
  (*_k)["Results"]["Sample Database"] = _sampleDatabase;

  _modelEvaluationCount = _hamiltonian->getNumHamiltonianObjectUpdates();

  delete _hamiltonian;
  delete _integrator;

  return;
}

double HMC::findReasonableStepSize(std::vector<double> q)
{
  double stepSize = _stepSize;
  double oldLogP, newLogP;

  if (_version == "Riemannian Const")
  {
    _hamiltonian->updateMetricMatricesRiemannian(q, _k);
  }

  std::vector<double> p = _hamiltonian->sampleMomentum();
  ++_proposedSampleCount;

  _hamiltonian->updateHamiltonian(q, _k);
  oldLogP = -_hamiltonian->H(p);

  _integrator->step(q, p, stepSize, _hamiltonian, _k);

  if (_version == "Riemannian Const")
  {
    _hamiltonian->updateMetricMatricesRiemannian(q, _k);
  }

  _hamiltonian->updateHamiltonian(q, _k);
  newLogP = -_hamiltonian->H(p);

  int a = (newLogP - oldLogP > std::log(0.5)) ? 1 : -1;

  // TODO: Ask why Tobias updates oldLogP as this is not what Algorithm 5 says
  while (std::pow(std::exp(newLogP - oldLogP), a) > std::pow(2, -a))
  {
    stepSize = std::pow(2, a) * stepSize;

    oldLogP = newLogP;

    // Here leapfrog uses Kinetic Energy with metric instead of Identity
    _integrator->step(q, p, stepSize, _hamiltonian, _k);
    _hamiltonian->updateHamiltonian(q, _k);

    if (_version == "Riemannian Const")
    {
      _hamiltonian->updateMetricMatricesRiemannian(q, _k);
    }

    newLogP = -_hamiltonian->H(p);
  }

  // Catch Step Size = 0.0 -> No traversal of phase space
  if (stepSize <= 0.0)
  {
    KORALI_LOG_ERROR("Failed to find reasonable Step Size. Step Size is %+6.3e.\n", _stepSize);
  }

  return stepSize;
}

bool HMC::computeNoUTurnCriterion(const std::vector<double> &pLeft, const std::vector<double> &pRight, const std::vector<double> &rho) const
{
  double dotProductLeft, dotProductRight;
  std::vector<double> tmpVectorOne(_dimensions, 0.0);
  std::vector<double> tmpVectorTwo(_dimensions, 0.0);

  std::vector<double> pLeftAdjusted = pLeft;
  std::vector<double> pRightAdjusted = pRight;

  for (size_t i = 0; i < _dimensions; ++i)
  {
    pLeftAdjusted[i] *= _stepSize;
    pRightAdjusted[i] *= _stepSize;
  }

  std::transform(std::cbegin(rho), std::cend(rho), std::cbegin(pLeftAdjusted), std::begin(tmpVectorOne), std::minus<double>());
  std::transform(std::cbegin(rho), std::cend(rho), std::cbegin(pRightAdjusted), std::begin(tmpVectorTwo), std::minus<double>());
  dotProductLeft = dotProduct(tmpVectorOne, pLeft);
  dotProductRight = dotProduct(tmpVectorTwo, pRight);

  // dotProductLeft = std::inner_product(std::cbegin(pLeft), std::cend(pLeft), std::cbegin(tmpVectorOne), 0.0);
  // dotProductRight = std::inner_product(std::cbegin(pRight), std::cend(pRight), std::cbegin(tmpVectorTwo), 0.0);

  dotProductLeft = dotProduct(rho, pLeft);
  dotProductRight = dotProduct(rho, pRight);

  // std::cout << "Integral Version: " << std::endl;
  // std::cout << "dotProductLeft = " << dotProductLeft << std::endl;
  // std::cout << "dotProductRight = " << dotProductRight << std::endl;
  // std::cout << "--------------------------" << std::endl;

  return dotProductLeft > 0 && dotProductRight > 0;
}

void HMC::buildTreeUtil(TreeHelperEuclidean *helper)
{
  helper->qLeftOut = helper->qIn;
  helper->pLeftOut = helper->pIn;

  if (helper->depthIn == 0)
  {
    const double deltaMax = 100;
    _integrator->step(helper->qLeftOut, helper->pLeftOut, _stepSize, _hamiltonian, _k);

    _hamiltonian->updateHamiltonian(helper->qLeftOut, _k);
    const double leafK = _hamiltonian->K(helper->pLeftOut);
    const double leafU = _hamiltonian->U();
    const double leafH = leafU + leafK;

    helper->numValidLeavesOut = (helper->logUniSampleIn <= helper->rootHIn - leafH) ? 1.0 : 0.0;

    helper->buildCriterionOut = (helper->rootHIn - leafH + deltaMax > helper->logUniSampleIn);

    helper->alphaOut = std::min(1.0, std::exp(helper->rootHIn - leafH));
    helper->numLeavesOut = 1;
    helper->qRightOut = helper->qLeftOut;
    helper->pRightOut = helper->pLeftOut;
    helper->qProposedOut = helper->qLeftOut;
  }
  else
  {
    int numLeavesSubtree;
    bool buildCriterionSubtree;
    double dotProductLeft, dotProductRight, numValidLeavesSubtree, alphaSubtree;

    std::vector<double> qProposedSubtree(_dimensions, 0.0);
    std::vector<double> tmpVector(_dimensions, 0.0);

    helper->depthIn = helper->depthIn - 1;

    buildTreeUtil(helper);

    if (helper->buildCriterionOut == true)
    {
      TreeHelperEuclidean *helperSubtree = new TreeHelperEuclidean;
      helperSubtree->logUniSampleIn = helper->logUniSampleIn;
      helperSubtree->directionIn = helper->directionIn;
      helperSubtree->depthIn = helper->depthIn;
      helperSubtree->rootHIn = helper->rootHIn;

      if (helper->directionIn == -1)
      {
        helperSubtree->qIn = helper->qLeftOut;
        helperSubtree->pIn = helper->pLeftOut;

        buildTreeUtil(helperSubtree);

        // helperSubtree->qRightOut = --
        // helperSubtree->pRightOut = --
        numValidLeavesSubtree = helperSubtree->numValidLeavesOut;
        buildCriterionSubtree = helperSubtree->buildCriterionOut;
        alphaSubtree = helperSubtree->alphaOut;
        numLeavesSubtree = helperSubtree->numLeavesOut;
      }
      else
      {
        helperSubtree->qIn = helper->qRightOut;
        helperSubtree->pIn = helper->pRightOut;

        buildTreeUtil(helperSubtree);

        // helperSubtree->qLeftOut = --
        // helperSubtree->pLeftOut = --
        numValidLeavesSubtree = helperSubtree->numValidLeavesOut;
        buildCriterionSubtree = helperSubtree->buildCriterionOut;
        alphaSubtree = helperSubtree->alphaOut;
        numLeavesSubtree = helperSubtree->numLeavesOut;
      }

      // First check to avoid divising by zero
      if (numValidLeavesSubtree != 0 && _uniformGenerator->getRandomNumber() < numValidLeavesSubtree / (helper->numValidLeavesOut + numValidLeavesSubtree))
      {
        helper->qProposedOut = helperSubtree->qProposedOut;
      }

      helper->numValidLeavesOut += numValidLeavesSubtree;
      helper->alphaOut += alphaSubtree;
      helper->numLeavesOut += numLeavesSubtree;

      helper->buildCriterionOut = buildCriterionSubtree && helper->computeCriterion(_hamiltonian);

      delete helperSubtree;
    }
  }

  return;
}

void HMC::buildTreeUtilIntegration(TreeHelperRiemannian *helper, std::vector<double> &rho)
{
  helper->qLeftOut = helper->qIn;
  helper->pLeftOut = helper->pIn;

  if (helper->depthIn == 0)
  {
    const double deltaMax = 100;
    _integrator->step(helper->qLeftOut, helper->pLeftOut, _stepSize, _hamiltonian, _k);

    _hamiltonian->updateHamiltonian(helper->pLeftOut, _k);
    const double leafK = _hamiltonian->K(helper->pLeftOut);
    const double leafU = _hamiltonian->U();
    const double leafH = leafU + leafK;

    helper->numValidLeavesOut = (helper->logUniSampleIn <= helper->rootHIn - leafH) ? 1.0 : 0.0;

    helper->buildCriterionOut = (helper->rootHIn - leafH + deltaMax > helper->logUniSampleIn);

    helper->alphaOut = std::min(1.0, std::exp(helper->rootHIn - leafH));
    helper->numLeavesOut = 1;
    helper->qRightOut = helper->qLeftOut;
    helper->pRightOut = helper->pLeftOut;
    helper->qProposedOut = helper->qLeftOut;

    std::cout << "rho (before sum) = " << std::endl;
    __printVec(rho);
    // add latest p to rho
    std::transform(std::cbegin(rho), std::cend(rho), std::cbegin(helper->pRightOut), std::begin(rho), std::plus<double>());

    std::cout << "helper->pRightOut" << std::endl;
    __printVec(helper->pRightOut);
    std::cout << "rho (after sum) = " << std::endl;
    __printVec(rho);
  }
  else
  {
    int numLeavesSubtree;
    bool buildCriterionSubtree;
    double dotProductLeft, dotProductRight, numValidLeavesSubtree, alphaSubtree;

    std::vector<double> qProposedSubtree(_dimensions, 0.0);
    std::vector<double> tmpVector(_dimensions, 0.0);

    helper->depthIn = helper->depthIn - 1;

    std::vector<double> pStart = helper->pIn;

    std::vector<double> rhoFirstSubtree(_dimensions, 0.0);
    buildTreeUtilIntegration(helper, rhoFirstSubtree);

    if (helper->buildCriterionOut == true)
    {
      TreeHelperRiemannian *helperSubtree = new TreeHelperRiemannian;
      helperSubtree->logUniSampleIn = helper->logUniSampleIn;
      helperSubtree->directionIn = helper->directionIn;
      helperSubtree->depthIn = helper->depthIn;
      helperSubtree->rootHIn = helper->rootHIn;

      std::vector<double> rhoSecondSubtree(_dimensions, 0.0);
      if (helper->directionIn == -1)
      {
        helperSubtree->qIn = helper->qLeftOut;
        helperSubtree->pIn = helper->pLeftOut;

        buildTreeUtilIntegration(helperSubtree, rhoSecondSubtree);

        // helperSubtree->qRightOut = --
        // helperSubtree->pRightOut = --
        numValidLeavesSubtree = helperSubtree->numValidLeavesOut;
        buildCriterionSubtree = helperSubtree->buildCriterionOut;
        alphaSubtree = helperSubtree->alphaOut;
        numLeavesSubtree = helperSubtree->numLeavesOut;
      }
      else
      {
        helperSubtree->qIn = helper->qRightOut;
        helperSubtree->pIn = helper->pRightOut;

        buildTreeUtilIntegration(helperSubtree, rhoSecondSubtree);

        // helperSubtree->qLeftOut = --
        // helperSubtree->pLeftOut = --
        numValidLeavesSubtree = helperSubtree->numValidLeavesOut;
        buildCriterionSubtree = helperSubtree->buildCriterionOut;
        alphaSubtree = helperSubtree->alphaOut;
        numLeavesSubtree = helperSubtree->numLeavesOut;
      }

      std::cout << "rhoFirstSubtree = " << std::endl;
      __printVec(rhoFirstSubtree);

      std::cout << "rhoSecondSubtree = " << std::endl;
      __printVec(rhoSecondSubtree);

      std::vector<double> rhoSubtree = rhoFirstSubtree;

      std::cout << "rhoSubtree = (rhoSubtree = rhoFirstSubtree) " << std::endl;
      __printVec(rhoSubtree);

      std::transform(std::cbegin(rhoSubtree), std::cend(rhoSubtree), std::cbegin(rhoSecondSubtree), std::begin(rhoSubtree), std::plus<double>());

      std::cout << "rhoSubtree = (rhoSubtree = rhoFirstSubtree + rhoSecondSubtree) " << std::endl;
      __printVec(rhoSubtree);

      // add rho of subtree to main rho
      std::transform(std::cbegin(rho), std::cend(rho), std::cbegin(rhoSubtree), std::begin(rho), std::plus<double>());

      std::cout << "rho = (rho = rho + rhoFirstSubtree + rhoSecondSubtree)" << std::endl;
      __printVec(rho);

      // First check to avoid divising by zero
      if (numValidLeavesSubtree != 0 && _uniformGenerator->getRandomNumber() < numValidLeavesSubtree / (helper->numValidLeavesOut + numValidLeavesSubtree))
      {
        helper->qProposedOut = helperSubtree->qProposedOut;
      }

      helper->numValidLeavesOut += numValidLeavesSubtree;
      helper->alphaOut += alphaSubtree;
      helper->numLeavesOut += numLeavesSubtree;

      std::vector<double> pEnd = helper->directionIn == -1 ? helperSubtree->pLeftOut : helperSubtree->pRightOut;
      // helper->buildCriterionOut = buildCriterionSubtree && helper->computeCriterion(_hamiltonian, pStart, pEnd, rhoSubtree);
      helper->buildCriterionOut = false;

      delete helperSubtree;
    }
  }

  return;
}

void HMC::buildTree(const std::vector<double> &q, const std::vector<double> &p, const double logUniSample, const int direction, const int depth, const double stepSize, const double rootH, std::vector<double> &qLeft, std::vector<double> &pLeft, std::vector<double> &qRight, std::vector<double> &pRight, std::vector<double> &qProposed, double &numValidLeaves, bool &buildCriterion, double &alpha, int &numLeaves)
{
  qLeft = q;
  pLeft = p;

  if (depth == 0)
  {
    const double deltaMax = 100;
    _integrator->step(qLeft, pLeft, _stepSize, _hamiltonian, _k);

    const double leafK = _hamiltonian->K(pLeft);
    const double leafU = _hamiltonian->U();
    const double leafH = leafU + leafK;

    numValidLeaves = (logUniSample <= rootH - leafH) ? 1.0 : 0.0;

    buildCriterion = (rootH - leafH + deltaMax > logUniSample);
    alpha = std::min(1.0, std::exp(rootH - leafH));
    numLeaves = 1;
    qRight = qLeft;
    qProposed = qLeft;
    pRight = pLeft;
  }
  else
  {
    int numLeavesSubtree;
    bool buildCriterionSubtree;
    double dotProductLeft, dotProductRight, numValidLeavesSubtree, alphaSubtree;

    std::vector<double> nullPointOne(_dimensions);
    std::vector<double> nullPointTwo(_dimensions);
    std::vector<double> qProposedSubtree(_dimensions, 0.0);
    std::vector<double> tmpVector(_dimensions, 0.0);

    buildTree(q, p, logUniSample, direction, depth - 1, stepSize, rootH, qLeft, pLeft, qRight, pRight, qProposed, numValidLeaves, buildCriterion, alpha, numLeaves);

    if (buildCriterion == true)
    {
      if (direction == -1)
      {
        buildTree(qLeft, pLeft, logUniSample, direction, depth - 1, stepSize, rootH, qLeft, pLeft, nullPointOne, nullPointTwo, qProposedSubtree, numValidLeavesSubtree, buildCriterionSubtree, alphaSubtree, numLeavesSubtree);
      }
      else
      {
        buildTree(qRight, pRight, logUniSample, direction, depth - 1, stepSize, rootH, nullPointOne, nullPointTwo, qRight, pRight, qProposedSubtree, numValidLeavesSubtree, buildCriterionSubtree, alphaSubtree, numLeavesSubtree);
      }

      // First check to avoid divising by zero
      if (numValidLeavesSubtree != 0 && _uniformGenerator->getRandomNumber() < numValidLeavesSubtree / (numValidLeaves + numValidLeavesSubtree))
      {
        qProposed = qProposedSubtree;
      }

      numValidLeaves += numValidLeavesSubtree;
      alpha += alphaSubtree;
      numLeaves += numLeavesSubtree;

      std::transform(std::cbegin(qRight), std::cend(qRight), std::cbegin(qLeft), std::begin(tmpVector), std::minus<double>());
      dotProductLeft = std::inner_product(std::cbegin(tmpVector), std::cend(tmpVector), std::cbegin(pLeft), 0.0);
      dotProductRight = std::inner_product(std::cbegin(tmpVector), std::cend(tmpVector), std::cbegin(pRight), 0.0);

      buildCriterion = buildCriterionSubtree && (dotProductLeft > 0) && (dotProductRight > 0);
    }
  }

  return;
}

void HMC::buildTreeIntegrationCriterion(const std::vector<double> &q, const std::vector<double> &p, const double logUniSample, const int direction, const int depth, const double stepSize, const double rootH, std::vector<double> &qLeft, std::vector<double> &pLeft, std::vector<double> &qRight, std::vector<double> &pRight, std::vector<double> &qProposed, double &numValidLeaves, bool &buildCriterion, double &alpha, int &numLeaves, std::vector<double> &rho)
{
  qLeft = q;
  pLeft = p;

  if (depth == 0)
  {
    const double deltaMax = 100;
    _integrator->step(qLeft, pLeft, _stepSize, _hamiltonian, _k);

    // std::transform(std::cbegin(rho), std::cend(rho), std::cbegin(pLeft), std::begin(rho), std::plus<double>());

    // for (size_t i = 0; i <_dimensions; ++i)
    // {
    //   rho[i] += _stepSize * pLeft[i];
    // }

    const double leafK = _hamiltonian->K(pLeft);
    const double leafU = _hamiltonian->U();
    const double leafH = leafU + leafK;

    numValidLeaves = (logUniSample <= rootH - leafH) ? 1.0 : 0.0;

    buildCriterion = (rootH - leafH + deltaMax > logUniSample);
    alpha = std::min(1.0, std::exp(rootH - leafH));
    numLeaves = 1;
    qRight = qLeft;
    qProposed = qLeft;
    pRight = pLeft;
  }
  else
  {
    int numLeavesSubtree;
    bool buildCriterionSubtree;
    double dotProductLeft, dotProductRight, numValidLeavesSubtree, alphaSubtree;

    std::vector<double> nullPointOne(_dimensions);
    std::vector<double> nullPointTwo(_dimensions);
    std::vector<double> qProposedSubtree(_dimensions, 0.0);
    std::vector<double> tmpVector(_dimensions, 0.0);
    std::vector<double> rho1(_dimensions, 0.0);
    std::vector<double> rho2(_dimensions, 0.0);

    buildTreeIntegrationCriterion(q, p, logUniSample, direction, depth - 1, stepSize, rootH, qLeft, pLeft, qRight, pRight, qProposed, numValidLeaves, buildCriterion, alpha, numLeaves, rho1);

    if (buildCriterion == true)
    {
      if (direction == -1)
      {
        buildTreeIntegrationCriterion(qLeft, pLeft, logUniSample, direction, depth - 1, stepSize, rootH, qLeft, pLeft, nullPointOne, nullPointTwo, qProposedSubtree, numValidLeavesSubtree, buildCriterionSubtree, alphaSubtree, numLeavesSubtree, rho2);
      }
      else
      {
        buildTreeIntegrationCriterion(qRight, pRight, logUniSample, direction, depth - 1, stepSize, rootH, nullPointOne, nullPointTwo, qRight, pRight, qProposedSubtree, numValidLeavesSubtree, buildCriterionSubtree, alphaSubtree, numLeavesSubtree, rho2);
      }

      // First check to avoid divising by zero
      if (numValidLeavesSubtree != 0 && _uniformGenerator->getRandomNumber() < numValidLeavesSubtree / (numValidLeaves + numValidLeavesSubtree))
      {
        qProposed = qProposedSubtree;
      }

      numValidLeaves += numValidLeavesSubtree;
      alpha += alphaSubtree;
      numLeaves += numLeavesSubtree;

      std::transform(std::cbegin(qRight), std::cend(qRight), std::cbegin(qLeft), std::begin(tmpVector), std::minus<double>());
      dotProductLeft = std::inner_product(std::cbegin(tmpVector), std::cend(tmpVector), std::cbegin(pLeft), 0.0);
      dotProductRight = std::inner_product(std::cbegin(tmpVector), std::cend(tmpVector), std::cbegin(pRight), 0.0);

      buildCriterion = buildCriterionSubtree && (dotProductLeft > 0) && (dotProductRight > 0);

      // std::cout << "direction = " << direction << std::endl;
      // std::cout << "depth = " << depth << std::endl;
      // std::cout << "Normal difference: " << std::endl;
      // std::cout << "dotProductLeft = " << dotProductLeft << std::endl;
      // std::cout << "dotProductRight = " << dotProductRight << std::endl;

      // std::vector<double> rhoSubtree = rho1;

      // std::transform(std::cbegin(rhoSecondSubtree), std::cend(rhoSecondSubtree), std::cbegin(rhoSubtree), std::begin(rhoSubtree), std::plus<double>());
      // std::transform(std::cbegin(rhoSubtree), std::cend(rhoSubtree), std::cbegin(rho), std::begin(rho), std::plus<double>());
      // for (size_t i = 0; i <_dimensions; ++i)
      // {
      //   rhoSubtree[i] += rho2[i];
      //   rho[i] += rhoSubtree[i];
      // }

      // std::vector<double> p_ = direction == -1 ? pLeft : pRight;
      // buildCriterion = buildCriterionSubtree && computeNoUTurnCriterion(p, p_, rhoSubtree);
    }
  }

  return;
}

void HMC::__printVec(const std::vector<double> vec) const
{
  for (size_t i = 0; i < vec.size(); ++i)
  {
    std::cout << vec[i] << std::endl;
  }
  return;
}

bool HMC::isNan(const std::vector<double> vec) const
{
  bool result = false;
  for (size_t i = 0; i < vec.size(); ++i)
  {
    if (std::isfinite(vec[i]) == false)
    {
      result = true;
    }
  }

  return result;
}

} // namespace sampler

} // namespace solver

} // namespace korali
