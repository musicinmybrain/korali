#ifndef _KORALI_SOLVER_HMC_HPP_
#define _KORALI_SOLVER_HMC_HPP_

// TODO: REMOVE normal/normal.hpp
#include "modules/distribution/multivariate/normal/normal.hpp"
#include "modules/distribution/univariate/normal/normal.hpp"
#include "modules/distribution/univariate/uniform/uniform.hpp"
#include "modules/solver/sampler/sampler.hpp"
#include <vector>

#include "hamiltonian_dense.hpp"
#include "hamiltonian_diag.hpp"
#include "leapfrog_explicit.hpp"
#include "tree_helper.hpp"

namespace korali
{
namespace solver
{
namespace sampler
{
class HMC : public Sampler
{
  Hamiltonian *_hamiltonian;
  Leapfrog *_integrator;

  /**
  * @brief Updates internal state such as mean, Metric and InverseMetric.
  */
  void updateState();

  /**
  * @brief Updates internal state such as mean, Metric and InverseMetric during warmup phase.
  */
  void updateStateWarmup();

  /**
  * @brief Updates internal state such as mean, Metric and InverseMetric during sampling phase.
  */
  void updateStateSampling();

  /**
  * @brief Generate new sample.
  * @return Sample of Momentum.
  */
  std::vector<double> generateCandidate();

  /**
  * @brief Process sample after evaluation.
  */
  void finishSample(size_t sampleId);

  public:
  /**
 * @brief Configures HMC.
 */
  void setInitialConfiguration() override;

  /**
  * @brief Final console output at termination.
  */
  void finalize() override;

  /**
  * @brief Generate a sample and evaluate it.
  */
  void runGeneration() override;

  /**
  * @brief Runs generation for HMC sampler.
  * @param logUniSample Log of uniform sample needed for Metropolis accepance / rejection step.
  */
  void runGenerationHMC(const double logUniSample);

  /**
  * @brief Rund NUTS algorithm with buildTreeUtil.
  * @param helper Helper struct for large argument list.
  */
  void runGenerationNUTSUtil(TreeHelper &helper);

  /**
  * @brief Runs generation for NUTS.
  * @param logUniSample Log of uniform sample needed for Metropolis accepance / rejection step.
  */
  void runGenerationNUTS(const double logUniSample);

  /**
  * @brief Saves sample.
  */
  void saveSample();

  /**
  * @brief Updates Step Size for Adaptive Step Size.
  */
  void updateStepSize();

  /**
  * @brief Console Output before generation runs.
  */
  void printGenerationBefore() override;

  /**
  * @brief Console output after generation.
  */
  void printGenerationAfter() override;

  /**
  * @brief Inner product induced by Inverse Metric.
  * @param pLeft Left argument of dot product.
  * @param pRight Right argumnt of dot procudt.
  * @return Inner product p^T * M ^ (-1) * p where M is the Metric.
  */
  double dotProduct(const std::vector<double> &pLeft, const std::vector<double> &pRight) const;

  /**
  * @brief Finds reasonable Step Size. Used if Use Adaptive Time Stepping is set to True.
  * @param q Current position.
  * @return The reasonable Step Size found by algorithm.
  */
  double findReasonableStepSize(std::vector<double> q);

  /**
  * @brief Checks if No U-Turn criterion is met.
  * @param pLeft Left momentum.
  * @param pRight Right momentum.
  * @param rho Distance of position calculated by integrating momentum and multiplying with Inverse Metric.
  * @return Boolean indicating if No U-Turn was found.
  */
  bool computeNoUTurnCriterion(const std::vector<double> &pLeft, const std::vector<double> &pRight, const std::vector<double> &rho) const;

  /**
  * @brief Recursive binary tree building algorithm. Used if Use NUTS is set to True.
  * @param helper Helper struct for large argument list.
  */
  void buildTreeUtil(TreeHelper &helper);

  /**
  * @brief Recursive binary tree building algorithm. Used if Use NUTS is set to True.
  * @param q Current Position.
  * @param p Current Momentum.
  * @param logUniSample Log of uniform sample from [0.0, 1.0).
  * @param direction Direction in which Hamiltonian Dynamics are evolved (either 1 or -1).
  * @param depth Depth of binary tree recursion.
  * @param stepSize Step Size used for integration scheme (Leap Frog).
  * @param rootH Original total energy from starting position (root of tree).
  * @param qLeft Leftmost leaf of binary tree (position).
  * @param pLeft Leftmost leaf of binary tree (momentum).
  * @param qRight Rightmost leaf of binary tree (positon).
  * @param pRight Rightmost leaf of binary tree (momentum).
  * @param qProposed Newly visited position (and thus proposed) state.
  * @param numValidLeaves Number of leaves visited in binary tree that have been visited and fulfill detailed balance condition.
  * @param buildCriterion Indicates if binary tree should be built further, i.e. if it is false a U-Turn has been found or the error has grown to be too large.
  * @param alpha Acceptance probability.
  * @param numLeaves Number of leaves visited in binary tree (do not necessarily fulfill detailed balance).
  */
  void buildTree(const std::vector<double> &q, const std::vector<double> &p, const double logUniSample, const int direction, const int depth, const double stepSize, const double rootH, std::vector<double> &qLeft, std::vector<double> &pLeft, std::vector<double> &qRight, std::vector<double> &pRight, std::vector<double> &qProposed, double &numValidLeaves, bool &buildCriterion, double &alpha, int &numLeaves);

  /**
  * @brief Recursive binary tree building algorithm. Used if Use NUTS is set to True.
  * @param q Current Position.
  * @param p Current Momentum.
  * @param logUniSample Log of uniform sample from [0.0, 1.0).
  * @param direction Direction in which Hamiltonian Dynamics are evolved (either 1 or -1).
  * @param depth Depth of binary tree recursion.
  * @param stepSize Step Size used for integration scheme (Leap Frog).
  * @param rootH Original total energy from starting position (root of tree).
  * @param qLeft Leftmost leaf of binary tree (position).
  * @param pLeft Leftmost leaf of binary tree (momentum).
  * @param qRight Rightmost leaf of binary tree (positon).
  * @param pRight Rightmost leaf of binary tree (momentum).
  * @param qProposed Newly visited position (and thus proposed) state.
  * @param numValidLeaves Number of leaves visited in binary tree that have been visited and fulfill detailed balance condition.
  * @param buildCriterion Indicates if binary tree should be built further, i.e. if it is false a U-Turn has been found or the error has grown to be too large.
  * @param alpha Acceptance probability.
  * @param numLeaves Number of leaves visited in binary tree (do not necessarily fulfill detailed balance).
  * @param rho Distance of position calculated by integrating momentum and multiplying with Inverse Metric.
  */
  void buildTreeIntegrationCriterion(const std::vector<double> &q, const std::vector<double> &p, const double logUniSample, const int direction, const int depth, const double stepSize, const double rootH, std::vector<double> &qLeft, std::vector<double> &pLeft, std::vector<double> &qRight, std::vector<double> &pRight, std::vector<double> &qProposed, double &numValidLeaves, bool &buildCriterion, double &alpha, int &numLeaves, std::vector<double> &rho);
};

} // namespace sampler
} // namespace solver
} // namespace korali

#endif // _KORALI_SOLVER_HMC_HPP_
