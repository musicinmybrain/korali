#ifndef _KORALI_SOLVER_HMC_HPP_
#define _KORALI_SOLVER_HMC_HPP_

// TODO: REMOVE normal/normal.hpp
#include "modules/distribution/univariate/normal/normal.hpp"
#include "modules/distribution/univariate/uniform/uniform.hpp"
#include "modules/distribution/multivariate/normal/normal.hpp"
#include "modules/solver/sampler/sampler.hpp"
#include <vector>

namespace korali
{
namespace solver
{
namespace sampler
{
class HMC : public Sampler
{
  private:
  /**
  * @brief Calculates recursively acceptance probability. Recursion required for Delayed Rejection.
  * @param denominator denominator of quotient (acceptance probability)
  * @param leaderLoglikelihood loglikelihood of current chain leader
  * @param loglikelihoods loglikelihoods of samples obtained after delay
  * @param N rescursion depth
  */

  /**
  * @brief Updates internal state such as mean and covariance of chain.
  */
  void updateState();

  /**
  * @brief Generate new sample.
  */
  void generateCandidate();

  /**
  * @brief Process sample after evaluation.
  */
  void finishSample(size_t sampleId);

  public:
  /**
 * @brief Configures HMC.
 */
  void setInitialConfiguration() override;

  /**
  * @brief Final console output at termination.
  */
  void finalize() override;

  /**
  * @brief Generate a sample and evaluate it.
  */
  void runGeneration() override;

  /**
  * @brief Console Output before generation runs.
  */
  void printGenerationBefore() override;

  /**
  * @brief Console output after generation.
  */
  void printGenerationAfter() override;

  /**
  * @brief Kinetic energy used for Hamiltonian Dynamics.
  */
  double K(std::vector<double> p);

  /**
  * @brief Gradient of kinetic energy used for Hamiltonian Dynamics.
  */
  std::vector<double> dK(std::vector<double> p);

  /**
  * @brief Potential energy used for Hamiltonian Dynamics with relation U(x) = -logP(x).
  */
  double U(std::vector<double> q);

  /**
  * @brief Gradient of potential energy used for Hamiltonian Dynamics with relation grad(U(x)) = -grad(logP(x)).
  */
  std::vector<double> dU(std::vector<double> q);

  /**
  * @brief Leapfrog stepping scheme used for evolving Hamiltonian Dynamics.
  */
  void leapFrogStep(std::vector<double>& q, std::vector<double>& p, const double stepSize);

  /**
  * @brief Inverts matrix in first argument. Solution is given in second argument. Used for Euclidean Metric as Metric has to be calculated from InverseMetric.
  */
  void invertMatrix(std::vector<double>& mat, std::vector<double>& inverseMat);
  
  /**
  * @brief Finds reasonable Step Size. Used if Use Adaptive Time Stepping is set to True.
  */
  double findReasonableStepSize(std::vector<double> q);

  /**
  * @brief Recursive binary tree building algorithm. Used if Use NUTS is set to True.
  */
  void buildTree(const std::vector<double>& q, const std::vector<double>& p, const double uniSample, const int direction, const int depth, const double stepSize, const double oldH, std::vector<double>& qMin, std::vector<double>& pMin, std::vector<double>& qPlus, std::vector<double>& pPlus, std::vector<double>& qPrime, double& nPrime, bool& buildCriterionPrime, double& alphaPrime, int& nAlphaPrime);
};

} // namespace sampler
} // namespace solver
} // namespace korali

#endif // _KORALI_SOLVER_HMC_HPP_
