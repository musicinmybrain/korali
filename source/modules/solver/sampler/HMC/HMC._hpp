#ifndef _KORALI_SOLVER_HMC_HPP_
#define _KORALI_SOLVER_HMC_HPP_

// TODO: REMOVE normal/normal.hpp
#include "modules/distribution/multivariate/normal/normal.hpp"
#include "modules/distribution/univariate/normal/normal.hpp"
#include "modules/distribution/univariate/uniform/uniform.hpp"
#include "modules/solver/sampler/sampler.hpp"
#include <vector>

namespace korali
{
namespace solver
{
namespace sampler
{
class HMC : public Sampler
{
  private:
  /**
  * @brief Updates internal state such as mean, Metric and InverseMetric.
  */
  void updateState();

  /**
  * @brief Updates internal state such as mean, Metric and InverseMetric during warmup phase.
  */
  void updateStateWarmup();

  /**
  * @brief Updates internal state such as mean, Metric and InverseMetric during sampling phase.
  */
  void updateStateSampling();

  /**
  * @brief Generate new sample.
  */
  void generateCandidate();

  /**
  * @brief Process sample after evaluation.
  */
  void finishSample(size_t sampleId);

  public:
  /**
 * @brief Configures HMC.
 */
  void setInitialConfiguration() override;

  /**
  * @brief Final console output at termination.
  */
  void finalize() override;

  /**
  * @brief Generate a sample and evaluate it.
  */
  void runGeneration() override;

  /**
  * @brief Runs generation for HMC sampler.
  * @param logUniSample Log of uniform sample needed for Metropolis accepance / rejection step.
  */
  void runGenerationHMC(const double logUniSample);

  /**
  * @brief Runs generation for NUTS.
  * @param logUniSample Log of uniform sample needed for Metropolis accepance / rejection step.
  */
  void runGenerationNUTS(const double logUniSample);

  /**
  * @brief Saves sample.
  */
  void saveSample();

  /**
  * @brief Updates Step Size for Adaptive Step Size.
  */
  void updateStepSize();

  /**
  * @brief Console Output before generation runs.
  */
  void printGenerationBefore() override;

  /**
  * @brief Console output after generation.
  */
  void printGenerationAfter() override;

  /**
  * @brief Kinetic energy used for Hamiltonian Dynamics.
  * @param p Current momentum.
  * @return Kinetic energy with current momentum.
  */
  double K(const std::vector<double> &p) const;

  /**
  * @brief Gradient of kinetic energy used for Hamiltonian Dynamics.
  * @param p Current momentum.
  * @return Gradient of kinetic energy with current momentum.
  */
  std::vector<double> dK(const std::vector<double> &p) const;

  /**
  * @brief Potential energy used for Hamiltonian Dynamics with relation U(x) = -logP(x).
  * @param q Current position.
  * @return Potential energy with current position.
  */
  double U(const std::vector<double> &q);

  /**
  * @brief Gradient of potential energy used for Hamiltonian Dynamics with relation grad(U(x)) = -grad(logP(x)).
  * @param q Current position.
  * @return Gradent of potential energy with current position.
  */
  std::vector<double> dU(const std::vector<double> &q);

  /**
  * @brief Leapfrog stepping scheme used for evolving Hamiltonian Dynamics.
  * @param q Position which is evolved.
  * @param p Momentum which is evolved.
  * @param stepSize Step Size used for Leap Frog Scheme.
  */
  void leapFrogStep(std::vector<double> &q, std::vector<double> &p, const double stepSize);

  /**
  * @brief Inverts matrix in first argument. Solution is given in second argument. Used for Euclidean Metric as Metric has to be calculated from InverseMetric.
  * @param mat Input matrix.
  * @param inverseMat Output matrix which is mat^(-1).
  */
  void invertMatrix(std::vector<double> &mat, std::vector<double> &inverseMat);

  /**
  * @brief Finds reasonable Step Size. Used if Use Adaptive Time Stepping is set to True.
  * @param q Current position.
  * @return The reasonable Step Size found by algorithm.
  */
  double findReasonableStepSize(std::vector<double> q);

  /**
  * @brief Recursive binary tree building algorithm. Used if Use NUTS is set to True.
  * @param q Current Position.
  * @param p Current Momentum.
  * @param logUniSample Log of uniform sample from [0.0, 1.0).
  * @param direction Direction in which Hamiltonian Dynamics are evolved (either 1 or -1).
  * @param depth Depth of binary tree recursion.
  * @param stepSize Step Size used for integration scheme (Leap Frog).
  * @param rootH Original total energy from starting position (root of tree).
  * @param qLeft Leftmost leaf of binary tree (position).
  * @param pLeft Leftmost leaf of binary tree (momentum).
  * @param qRight Rightmost leaf of binary tree (positon).
  * @param pRight Rightmost leaf of binary tree (momentum).
  * @param qProposed Newly visited position (and thus proposed) state.
  * @param numValidLeaves Number of leaves visited in binary tree that have been visited and fulfill detailed balance condition.
  * @param buildCriterion Indicates if binary tree should be built further, i.e. if it is false a U-Turn has been found or the error has grown to be too large.
  * @param alpha Acceptance probability.
  * @param numLeaves Number of leaves visited in binary tree (do not necessarily fulfill detailed balance).
  */
  void buildTree(const std::vector<double> &q, const std::vector<double> &p, const double logUniSample, const int direction, const int depth, const double stepSize, const double rootH, std::vector<double> &qLeft, std::vector<double> &pLeft, std::vector<double> &qRight, std::vector<double> &pRight, std::vector<double> &qProposed, double &numValidLeaves, bool &buildCriterion, double &alpha, int &numLeaves);
};

} // namespace sampler
} // namespace solver
} // namespace korali

#endif // _KORALI_SOLVER_HMC_HPP_
