#include "modules/solver/integrator/integrator.hpp"
#include "modules/conduit/conduit.hpp"
#include "modules/engine/engine.hpp"

void korali::solver::Integrator::setInitialConfiguration()
{
  _integral = 0;
  _sampleCount = 1;
  for( size_t i = 0; i<_k->_variables.size(); i++ )
    _sampleCount *= _k->_variables[i]->_samplePoints.size();
  _maxModelEvaluations     = std::min(_maxModelEvaluations, _sampleCount);
  _indicesHelper.resize(_k->_variables.size());
  double helper;
  _indicesHelper[0] = _k->_variables[0]->_samplePoints.size();
  _indicesHelper[1] = _k->_variables[0]->_samplePoints.size();
  for( size_t i = 2; i<_indicesHelper.size(); i++ )
  {
  	_indicesHelper[i] = _indicesHelper[i-1]*_k->_variables[i-1]->_samplePoints.size();
  }
}

void korali::solver::Integrator::runGeneration()
{
  if (_k->_currentGeneration == 1) setInitialConfiguration();

  _executionsPerGeneration = std::min(_executionsPerGeneration, _maxModelEvaluations - _modelEvaluationCount);
  
  std::vector<korali::Sample> samples(_executionsPerGeneration);
  std::vector<double> sampleData(_k->_variables.size());
  std::vector<std::vector<size_t>> usedIndices(_executionsPerGeneration,std::vector<size_t>(_k->_variables.size()));

  size_t rest, index;
  for(size_t i = 0; i < _executionsPerGeneration; i++)
  {
  	rest = _modelEvaluationCount;
    for( int d = _k->_variables.size()-1; d >= 0; d-- ) 
    {   
    	// We assume i = _index[0] + _index[1]*_sample[1].size() + _index[1]*_index[2]*_sample[2].size() + .....
    	if( d == 0 ) index = rest % _indicesHelper[d];
    	else index = rest / _indicesHelper[d];
    	rest -= index * _indicesHelper[d];

        sampleData[d] = _k->_variables[d]->_samplePoints[index];
        usedIndices[i][d] = index;
    }

    korali::logInfo("Detailed", "Running sample %zu/%zu with values:\n         ", _modelEvaluationCount+1,_sampleCount);
    for(auto& x : sampleData) korali::logData("Detailed", " %le   ", x);
    korali::logData("Detailed", "\n");

    samples[i]["Operation"]  = "Execute";
    samples[i]["Parameters"] = sampleData;
    samples[i]["Sample Id"]  = _modelEvaluationCount;
    _engine->_conduit->start(samples[i]);
    _modelEvaluationCount++;
  }
  _engine->_conduit->waitAll(samples);

  double weight, f;
  for (size_t i = 0; i < _executionsPerGeneration; i++)
  {
    weight = 1;
    for(size_t d = 0; d<_k->_variables.size(); d++){
      weight *= _k->_variables[d]->_quadratureWeights[usedIndices[i][d]];
    }
    f = samples[i]["Evaluation"];
    _integral += weight*f;
  }
  (*_k)["Results"]["Integral"] = _integral;
}

void korali::solver::Integrator::printGenerationBefore()
{
}

void korali::solver::Integrator::printGenerationAfter()
{
 korali::logInfo("Minimal", "Total Terms summed %lu/%lu.\n", _modelEvaluationCount, _sampleCount);
}

void korali::solver::Integrator::finalize()
{
	korali::logInfo("Minimal", "Integral Calculated: %e\n", _integral);
}

