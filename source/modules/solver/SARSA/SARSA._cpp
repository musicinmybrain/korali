#include "modules/solver/SARSA/SARSA.hpp"
#include "modules/conduit/conduit.hpp"

void korali::solver::SARSA::setInitialConfiguration()
{
 knlohmann::json problemConfig = (*_k)["Problem"];
 size_t actionSize = problemConfig["Action Vector Size"];
 size_t stateSize = problemConfig["State Vector Size"];

 std::vector<size_t> hiddenLayers = { 32, 32 };
 std::vector<size_t> hiddenLayersShape = { stateSize, hiddenLayers[0], hiddenLayers[1], hiddenLayers[1], actionSize };
 std::vector<size_t> inputLayerVector = { 1, 0, 0, 0, 0 };
 std::vector<size_t> outputLayerVector = { 0, 0, 0, 0, 1 };

 _builder.addInput(stateSize);
 _builder.addLayer(hiddenLayers[0], "Sigm");
 _builder.addLayer(hiddenLayers[1], "Sigm");
 _builder.addLayer(actionSize,  "Linear", true);

 _builder.build();

 printf("actionSize: %lu, stateSize: %lu\n", actionSize, stateSize);

 _activation = new smarties::Activation(hiddenLayersShape, outputLayerVector, inputLayerVector);
}

void korali::solver::SARSA::runGeneration()
{
 if (_k->_currentGeneration == 1) setInitialConfiguration();

 _k->_logger->logInfo("Normal", "Running generation %lu...\n", _k->_currentGeneration);

 auto maxConcurrency = _conduit->maxConcurrency();
 printf("Max Concurrency: %lu\n", maxConcurrency);

 std::vector<Sample> samples(_environmentCount);
 std::vector<Environment> envs(_environmentCount);

 // Initializing Environments
 size_t curEnv = 0;
 while (curEnv < _environmentCount)
 {
  for (size_t i = 0; i < maxConcurrency && curEnv < _environmentCount; i++)
  {
   samples[curEnv]["Worker"] = i;
   samples[curEnv]["Sample Id"] = curEnv;
   samples[curEnv]["Module"] = "Problem";
   samples[curEnv]["Operation"] = "Run Environment";
   _conduit->start(samples[curEnv]);
   curEnv++;
  }
 }

 // Running action-state loop
 size_t finishedEnvs = 0;
 while (finishedEnvs < _environmentCount)
 {
   auto envId = _conduit->waitAny(samples);

   if (samples[envId]["Finished"] == true)
   {
    printf("Env Finished: %lu\n", envId);
    finishedEnvs++;
   }
   else
   {
    processEpisode(samples[envId], envs[envId]);
    // Set action
    // samples[envId]["Action"] = envs[envId].action;
    _conduit->start(samples[envId]);
   }
 }

}

void korali::solver::SARSA::processEpisode(korali::Sample& sample, korali::solver::Environment& env)
{
 knlohmann::json problemConfig = (*_k)["Problem"];

 size_t actionSize = problemConfig["Action Vector Size"];
 size_t stateSize = problemConfig["State Vector Size"];

 std::string sampleString = "['State']";

 if ( korali::JsonInterface::isDefined(sample._js.getJson(), sampleString) == false)
   _k->_logger->logError("The RL problem requires that the environment function returns ['State'] values.\n");

 std::vector<double> state = sample["State"];
 size_t resultStateVectorSize = state.size();

 if (resultStateVectorSize != stateSize)
  _k->_logger->logError("The returned state vector size (%lu) is different from the number of state variables (%lu)\n.", resultStateVectorSize, stateSize);

 auto action = _builder.net->forward(state, _activation);

 for (size_t i = 0; i < action.size(); i++)
  printf("Action: %f\n", action[i]);
}

void korali::solver::SARSA::printGenerationBefore()
{
 _k->_logger->logInfo("Normal", "Preparing to start generation...\n");
}

void korali::solver::SARSA::printGenerationAfter()
{
 _k->_logger->logInfo("Normal", "Finished to generation %lu...\n", _k->_currentGeneration);
}

