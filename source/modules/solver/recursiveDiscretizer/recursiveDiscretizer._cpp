#include "modules/solver/recursiveDiscretizer/recursiveDiscretizer.hpp"
#include "modules/conduit/conduit.hpp"

void korali::solver::RecursiveDiscretizer::setInitialConfiguration()
{
 // Initialize by populating the initial possibility space
 size_t policyCount = 1;
 size_t policyDepth = _k->_currentGeneration;
 size_t varCount = _k->_variables.size();

 _policyCollection.resize(_recursionDepth);

 for (size_t i = 0; i < _k->_variables.size(); i++) policyCount *= (_k->_variables[i]->_intervalCount+1);

 _policyCollection[0].resize(policyCount);
 for (size_t i = 0; i < policyCount; i++) _policyCollection[0][i].resize(varCount);

 size_t currentStride = 1;

 for (int i = _k->_variables.size()-1; i >= 0; i--)
 {
  double intervalLength = (_k->_variables[i]->_upperBound + _k->_variables[i]->_lowerBound) / (double)_k->_variables[i]->_intervalCount;

  size_t currentPolicy = 0;
  while (currentPolicy < policyCount)
  for (size_t j = 0; j < _k->_variables[i]->_intervalCount+1; j++)
  {
   double point = (double)j * intervalLength;
   for (size_t k = 0; k < currentStride; k++)
   {
    _policyCollection[0][currentPolicy][i] = point;
    currentPolicy++;
   }
  }

  currentStride *= (_k->_variables[i]->_intervalCount+1);
 }

 // Evaluating Constraints
 std::vector<korali::Sample> cSamples(policyCount);
 std::vector<double> sampleData(_k->_variables.size());
 for (size_t i = 0; i < cSamples.size(); i++)
 {
  for(size_t j = 0; j < varCount; j++) sampleData[j] = _policyCollection[0][i][j];
  cSamples[i]["Operation"]  = "Evaluate Constraints";
  cSamples[i]["Current Depth"] = _recursionDepth - 1;
  cSamples[i]["Policy"][0] = sampleData;
  cSamples[i]["Variables"] = cSamples[i]["Policy"][0];
  korali::_conduit->start(cSamples[i]);
 }

 korali::_conduit->waitAll(cSamples);

 for (size_t i = 0; i < cSamples.size(); i++)
  if (cSamples[i]["Constraint Evaluation"] >= 0)
  {
   cSamples[i]["Operation"]  = "Evaluate Cost Function";
   korali::_conduit->start(cSamples[i]);
  }

 korali::_conduit->waitAll(cSamples);

 _policyCollection[0].clear();
 _policyEvaluation.clear();

 for (size_t i = 0; i < cSamples.size(); i++)
  if (cSamples[i]["Constraint Evaluation"] >= 0)
  {
   _policyCollection[0].push_back(cSamples[i]["Policy"][0]);
   _policyEvaluation.push_back(cSamples[i]["Cost Evaluation"]);
  }
}

void korali::solver::RecursiveDiscretizer::runGeneration()
{

 if (_k->_currentGeneration == 1) { setInitialConfiguration(); return; }

 size_t currentDepth = _k->_currentGeneration-1;
 size_t policyCount = _policyCollection[currentDepth-1].size();
 size_t varCount = _k->_variables.size();

 _policyCollection[currentDepth].resize(policyCount);
 for (size_t i = 0; i < policyCount; i++) _policyCollection[currentDepth][i].resize(varCount);

 size_t candidateCount = 1;
 for (size_t i = 0; i < _k->_variables.size(); i++) candidateCount *= (_k->_variables[i]->_intervalCount+1);

 std::vector<std::vector<double>> candidateList(candidateCount);
 for (size_t i = 0; i < candidateCount; i++) candidateList[i].resize(varCount);

 size_t currentStride = 1;
 for (int i = _k->_variables.size()-1; i >= 0; i--)
 {
  double intervalLength = (_k->_variables[i]->_upperBound + _k->_variables[i]->_lowerBound) / (double)_k->_variables[i]->_intervalCount;

  size_t currentCandidate = 0;
  while (currentCandidate < candidateCount)
  for (size_t j = 0; j < _k->_variables[i]->_intervalCount+1; j++)
  {
   double point = (double)j * intervalLength;
   for (size_t k = 0; k < currentStride; k++)
   {
    candidateList[currentCandidate][i] = point;
    currentCandidate++;
   }
  }

  currentStride *= (_k->_variables[i]->_intervalCount+1);
 }

 std::vector<std::vector<std::vector<double>>> _newPolicyCollection(_recursionDepth);
 std::vector<double> _newPolicyEvaluations;

 for (size_t i = 0; i < policyCount; i++)
 {
  std::vector<korali::Sample> cSamples(candidateList.size());
  size_t currentSample = 0;

  for (size_t j = 0; j < candidateList.size(); j++)
  {
   for (size_t k = 0; k < varCount; k++) _policyCollection[currentDepth][i][k] = candidateList[j][k];

   for (size_t p = 0; p <= currentDepth; p++)
   {
    std::vector<double> coordinate(varCount);
    for (size_t k = 0; k < varCount; k++)  coordinate[k] = _policyCollection[p][i][k];
    cSamples[currentSample]["Policy"][p] = coordinate;
   }

   cSamples[currentSample]["Variables"] = cSamples[currentSample]["Policy"][currentDepth];
   cSamples[currentSample]["Previous Evaluation"] = _policyEvaluation[i];
   cSamples[currentSample]["Current Depth"] = _recursionDepth - _k->_currentGeneration;
   cSamples[currentSample]["Operation"]  = "Evaluate Constraints";
   korali::_conduit->start(cSamples[currentSample]);
   currentSample++;
  }

  korali::_conduit->waitAll(cSamples);

  for (int i = 0; i < cSamples.size(); i++)
   if (cSamples[i]["Constraint Evaluation"] >= 0)
   {
    cSamples[i]["Operation"]  = "Evaluate Cost Function";
    korali::_conduit->start(cSamples[i]);
   }

  korali::_conduit->waitAll(cSamples);

  double minCostEvaluation = korali::Inf;
  auto bestPolicy = cSamples[0]["Policy"];

  for (int i = 0; i < cSamples.size(); i++)
   if (cSamples[i]["Constraint Evaluation"] >= 0)
   {
    double currEval = cSamples[i]["Cost Evaluation"];
    double prevEval = cSamples[i]["Previous Evaluation"];
    double sumEval = currEval + prevEval;

    if (sumEval < minCostEvaluation)
    {
     bestPolicy = cSamples[i]["Policy"];
     minCostEvaluation = sumEval;
    }
   }

  if (minCostEvaluation < korali::Inf)
  {
   for (size_t p = 0; p <= currentDepth; p++)
   {
     auto newEntry = bestPolicy[p];
    _newPolicyCollection[p].push_back(newEntry);
   }

   _newPolicyEvaluations.push_back(minCostEvaluation);
  }
 }

 _policyCollection = _newPolicyCollection;
 _policyEvaluation = _newPolicyEvaluations;

 for (size_t i = 0; i < _policyCollection[0].size(); i++)
  for (size_t p = 0; p <= currentDepth; p++)
   for (size_t k = 0; k < varCount; k++)
    _k->_js["Results"]["Optimal Policies"][i][p][k] = _policyCollection[p][i][k];

 _k->_js["Results"]["Policy Evaluations"] = _policyEvaluation;

 double bestEval = korali::Inf;
 size_t bestEvalIdx = -1;
 for (size_t i = 0; i < _policyEvaluation.size(); i++) if (_policyEvaluation[i] < bestEval) { bestEval = _policyEvaluation[i]; bestEvalIdx = i; }
 _k->_js["Results"]["Best Policy Index"] = bestEvalIdx;
}

void korali::solver::RecursiveDiscretizer::printGenerationBefore()
{
}

void korali::solver::RecursiveDiscretizer::printGenerationAfter()
{
}
