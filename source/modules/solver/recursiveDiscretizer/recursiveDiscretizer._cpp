#include "modules/solver/recursiveDiscretizer/recursiveDiscretizer.hpp"
#include "modules/conduit/conduit.hpp"

void korali::solver::RecursiveDiscretizer::setInitialConfiguration()
{
 // Initialize by populating the initial possibility space
 size_t policyDepth = _k->_currentGeneration;
 size_t varCount = _k->_variables.size();

 _policyCollection.resize(_recursionDepth);

 // Generating Candidate List
 size_t candidateCount = 1;
 for (size_t i = 0; i < _k->_variables.size(); i++) candidateCount *= (_k->_variables[i]->_intervalCount+1);

 _candidateList.resize(candidateCount);
 for (size_t i = 0; i < candidateCount; i++) _candidateList[i].resize(varCount);

 size_t currentStride = 1;
 for (int i = _k->_variables.size()-1; i >= 0; i--)
 {
  double intervalLength = (_k->_variables[i]->_upperBound + _k->_variables[i]->_lowerBound) / (double)_k->_variables[i]->_intervalCount;

  size_t currentCandidate = 0;
  while (currentCandidate < candidateCount)
  for (size_t j = 0; j < _k->_variables[i]->_intervalCount+1; j++)
  {
   double point = (double)j * intervalLength;
   for (size_t k = 0; k < currentStride; k++)
   {
    _candidateList[currentCandidate][i] = point;
    currentCandidate++;
   }
  }

  currentStride *= (_k->_variables[i]->_intervalCount+1);
 }

 // Setting end-node
 _policyEvaluation.push_back(0);
}

void korali::solver::RecursiveDiscretizer::runGeneration()
{
 if (_k->_currentGeneration == 1) setInitialConfiguration();

 size_t currentDepth = _k->_currentGeneration-1;
 size_t policyCount = _policyEvaluation.size();
 size_t varCount = _k->_variables.size();

 std::vector<std::vector<std::vector<double>>> _newPolicyCollection(_k->_currentGeneration);
 std::vector<double> _newPolicyEvaluations;

 for (size_t i = 0; i < _candidateList.size(); i++)
 {
  std::vector<korali::Sample> cSamples(policyCount);
  size_t currentSample = 0;

  for (size_t j = 0; j < policyCount; j++)
  {
   for (size_t p = 0; p < currentDepth; p++)
     cSamples[currentSample]["Policy"][p] = _policyCollection[p][j];
   cSamples[currentSample]["Policy"][currentDepth] = _candidateList[i];

   cSamples[currentSample]["Variables"] = cSamples[currentSample]["Policy"][currentDepth];
   cSamples[currentSample]["Previous Evaluation"] = _policyEvaluation[j];
   cSamples[currentSample]["Current Depth"] = _recursionDepth - currentDepth - 1;
   cSamples[currentSample]["Operation"]  = "Evaluate Constraints";
   korali::_conduit->start(cSamples[currentSample]);
   currentSample++;
  }

  korali::_conduit->waitAll(cSamples);

  for (int i = 0; i < cSamples.size(); i++)
   if (cSamples[i]["Constraint Evaluation"] >= 0)
   {
    cSamples[i]["Operation"]  = "Evaluate Cost Function";
    korali::_conduit->start(cSamples[i]);
   }

  korali::_conduit->waitAll(cSamples);

  double minCostEvaluation = korali::Inf;
  auto bestPolicy = cSamples[0]["Policy"];

  for (int i = 0; i < cSamples.size(); i++)
   if (cSamples[i]["Constraint Evaluation"] >= 0)
   {
    double currEval = cSamples[i]["Cost Evaluation"];
    double prevEval = cSamples[i]["Previous Evaluation"];
    double sumEval = currEval + prevEval;

    if (sumEval < minCostEvaluation)
    {
     bestPolicy = cSamples[i]["Policy"];
     minCostEvaluation = sumEval;
    }
   }

  if (minCostEvaluation < korali::Inf)
  {
   for (size_t p = 0; p <= currentDepth; p++)
    _newPolicyCollection[p].push_back(bestPolicy[p]);
   _newPolicyEvaluations.push_back(minCostEvaluation);
  }
 }

 _policyCollection = _newPolicyCollection;
 _policyEvaluation = _newPolicyEvaluations;

 updateResults();
}

void korali::solver::RecursiveDiscretizer::updateResults()
{
 size_t currentDepth = _k->_currentGeneration;
 size_t varCount = _k->_variables.size();

 double bestEval = korali::Inf;
 size_t bestEvalIdx = -1;
 for (size_t i = 0; i < _policyEvaluation.size(); i++) if (_policyEvaluation[i] < bestEval) { bestEval = _policyEvaluation[i]; bestEvalIdx = i; }

 if (bestEvalIdx == -1) korali::logError("No feasible policy found due to overly tight constraints.\n");

  for (size_t p = 0; p < currentDepth; p++)
   for (size_t k = 0; k < varCount; k++)
    _k->_js["Results"]["Optimal Policy"][p][k] = _policyCollection[p][bestEvalIdx][k];

 _k->_js["Results"]["Policy Evaluation"] = _policyEvaluation[bestEvalIdx];
}

void korali::solver::RecursiveDiscretizer::printGenerationBefore()
{
}

void korali::solver::RecursiveDiscretizer::printGenerationAfter()
{
}
