#ifndef _KORALI_ENGINE_HPP_
#define _KORALI_ENGINE_HPP_

#include "modules/experiment/experiment.hpp"
#include "modules/conduit/distributed/distributed.hpp"
#include "modules/conduit/conduit.hpp"
#include "auxiliar/py2json.hpp"
#include <chrono>

namespace korali
{
 class Engine : public korali::Module
 {
  public:

  Engine();

  /**
    * @brief A singleton pointer to the execution conduit. Shared among all experiments.
    */
  korali::Conduit* _conduit;

  /**
   * @brief A pointer to the Engine's logger object.
  */
  korali::Logger* _logger;

  /**
    * @brief Stores the list of experiments to run.
    */
  std::vector<korali::Experiment*> _experimentVector;

  /**
    * @brief Stores a pointer to the current experiment.
    */
  korali::Experiment* _currentExperiment;

  /**
    * @brief Stores the main execution thread (coroutine).
    */
  cothread_t _thread;

  /**
   * @brief Saves the output path for the profiling information file
   */
  std::string _profilingPath;

  /**
  * @brief Specifies how much detail will be saved in the profiling file (None, Full)
  */
  std::string _profilingDetail;

  /**
  * @brief Specifies every how many generation will the profiling file be updated
  */
  double _profilingFrequency;

  /**
  * @brief Stores the timepoint of the last time the profiling information was saved.
  */
  std::chrono::time_point<std::chrono::high_resolution_clock> _profilingLastSave;

  /**
  * @brief Saves the profiling information to the specified path
  * @param forceSave Saves even if the current generation does not divide _profilingFrequency. Reserved for last generation.
  */
  void saveProfilingInfo(bool forceSave = false);

  /**
   * @brief Stores a set experiments into the experiment list and runs them to completion.
   * @param experiments Set of experiments.
   */
  void run(std::vector<korali::Experiment>& experiments);

  /**
   * @brief Stores a single experiment into the experiment list and runs it to completion.
   * @param experiments The experiment to run.
   */
  void run(korali::Experiment& experiment);

  /**
   * @brief Runs the stored list of experiments.
   */
  void run();

  /**
   * @brief C++ wrapper for the getItem operator.
   * @param key A C++ string acting as JSON key.
   * @return The referenced JSON object content.
  */
  knlohmann::json& operator[](const std::string& key);

  /**
   * @brief C++ wrapper for the getItem operator.
   * @param key A C++ integer acting as JSON key.
   * @return The referenced JSON object content.
  */
  knlohmann::json& operator[](const unsigned long int& key);

  /**
   * @brief Gets an item from the JSON object at the current pointer position.
   * @param key A pybind11 object acting as JSON key (number or string).
   * @return A pybind11 object
  */
  pybind11::object getItem(pybind11::object key);

  /**
   * @brief Sets an item on the JSON object at the current pointer position.
   * @param key A pybind11 object acting as JSON key (number or string).
   * @param val The value of the item to set.
  */
  void setItem(pybind11::object key, pybind11::object val);

  /**
   * @brief Stores the JSON based configuration for the engine.
  */
  korali::KoraliJson  _js;

  /**
   * @brief Returns the worker teams MPI communication pointer (Distributed Conduit only).
   */
  static long int getMPICommPointer();
 };

 /**
  * @brief Determines whether this is a dry run (no conduit initialization nor execution)
 */
 extern bool _isDryRun;
}

#endif
