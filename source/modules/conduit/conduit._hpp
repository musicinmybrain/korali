#ifndef _KORALI_CONDUIT_HPP_
#define _KORALI_CONDUIT_HPP_

#include "modules/module.hpp"
#include <vector>

namespace korali
{

class Engine;

class Conduit : public Module
{
  public:
  /**
 * @brief Accepts a sample for processing.
 * @param sample A Korali sample
 */
  virtual void processSample(Sample &sample) = 0;

  /**
  * @brief Initializes the worker/server bifurcation in the conduit
  */
  virtual void initServer(){};

  /**
 * @brief Determines whether the caller rank/thread/process is root.
 * @return True, if it is root; false, otherwise.
 */
  virtual bool isRoot() { return true; }

  /**
 * @brief broadcast global information for all workers to have when processing a sample. Useful for Korali-in-Korali solvers.
 * @param key Key onto which to save the global information
 * @param globalsJs JSON object with information to broadcast
 */
  virtual void broadcastGlobals(std::string key, knlohmann::json &globalsJs) = 0;

  /**
 * @brief Aborts execution for all ranks/threads/processes.
 */
  virtual void abort() { exit(-1); }

  /**
 * @brief Starts the execution of the sample.
 * @param sample A Korali sample
 */
  void start(Sample &sample);

  /**
  * @brief Waits for a given sample to finish. The experiment will not continue until the sample has been evaluated.
  * @param sample A Korali sample
  */
  void wait(Sample &sample);

  /**
   * @brief Waits for a set of sample to finish. The experiment will not continue until all samples have been evaluated.
   * @param samples A list of Korali samples
   */
  void waitAll(std::vector<Sample> &samples);

  /**
  * @brief Waits for a set of sample to finish. The experiment will not continue until at least one of the samples have been evaluated.
  * @param samples A list of Korali samples
  * @return Position in the vector of the sample that has finished.
  */
  size_t waitAny(std::vector<Sample> &samples);

  /**
  * @brief Sends an update to the engine to provide partial information while the sample is still active
  * @param message Message to send to engine
  */
  virtual void sendMessageToEngine(knlohmann::json& message) = 0;

  /**
  * @brief Blocking call that waits until any message incoming from the engine.
  * @return Message from the engine.
  */
  virtual knlohmann::json recvMessageFromEngine() = 0;

  /**
  * @brief Blocking call that waits until any message is received from any sample.
  * @param sample The sample from which to receive an update
  * @return Message from the sample.
  */
  virtual knlohmann::json recvMessageFromSample(Sample& sample) = 0;

  /**
  * @brief Sends an update to a still active sample
  * @param sample The sample from which to receive an update
  * @param Message Message to send to the sample.
  */
  virtual void sendMessageToSample(Sample& sample, knlohmann::json& message) = 0;

  /**
  * @brief Stacks a new Engine into the engine stack
  * @param engine A Korali Engine
  */
  virtual void stackEngine(Engine *engine){};

  /**
  * @brief Pops the current Engine from the engine stack
  */
  virtual void popEngine(){};

  /**
  * @brief Wrapper function for the sample coroutine
  */
  static void coroutineWrapper();
};

} // namespace korali

#endif // _KORALI_CONDUIT_HPP_
