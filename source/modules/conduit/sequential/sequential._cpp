#include "engine.hpp"
#include "modules/conduit/sequential/sequential.hpp"
#include "modules/experiment/experiment.hpp"
#include "modules/problem/problem.hpp"
#include "modules/solver/solver.hpp"
#include "sample/sample.hpp"

using namespace std;

namespace korali
{
namespace conduit
{

void Sequential::initialize()
{
}

void Sequential::processSample(Sample &sample)
{
  Engine *engine = _engineStack.top();

  auto js = knlohmann::json();
  js["Start Time"] = chrono::duration<double>(chrono::high_resolution_clock::now() - _startTime).count() + _cumulativeTime;

  _currentSample = &sample;
  sample._globals = &engine->_currentExperiment->_globals;
  sample.sampleLauncher();

  js["End Time"] = chrono::duration<double>(chrono::high_resolution_clock::now() - _startTime).count() + _cumulativeTime;
  js["Current Generation"] = engine->_currentExperiment->_currentGeneration;
  js["Solver Id"] = engine->_currentExperiment->_experimentId;
  __profiler["Timelines"]["Worker 0"] += js;
}

void Sequential::broadcastMessageToWorkers(knlohmann::json& message)
{

}

void Sequential::sendMessageToEngine(knlohmann::json& message)
{
 // Queueing outgoing message directly
 _currentSample->_outputMessageQueue.push(message);
}

knlohmann::json Sequential::recvMessageFromEngine()
{
 Engine *engine = _engineStack.top();

 // While there's no message, keep executing sample until there is
 while(_currentSample->_inputMessageQueue.empty())
  co_switch(engine->_currentExperiment->_thread);

 // Pulling message from incoming message queue
 auto message = _currentSample->_inputMessageQueue.front();
 _currentSample->_inputMessageQueue.pop();

 return message;
}

knlohmann::json Sequential::recvMessageFromSample(Sample& sample)
{
 // While there's no message, keep executing sample until there is
 while(sample._outputMessageQueue.empty())
 {
  _currentSample = &sample;
  co_switch(sample._sampleThread);
 }

 // Pulling message from outgoing message queue
 auto message = sample._outputMessageQueue.front();
 sample._outputMessageQueue.pop();

 return message;
}

void Sequential::sendMessageToSample(Sample& sample, knlohmann::json& message)
{
 // Queueing incomping message directly
 sample._inputMessageQueue.push(message);
}

} // namespace conduit

} // namespace korali
