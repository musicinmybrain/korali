#include "engine.hpp"
#include "modules/conduit/sequential/sequential.hpp"
#include "modules/experiment/experiment.hpp"
#include "modules/problem/problem.hpp"
#include "modules/solver/solver.hpp"
#include "sample/sample.hpp"

using namespace std;

namespace korali
{
namespace conduit
{

void Sequential::initialize()
{
}

void Sequential::processSample(Sample &sample)
{
  Engine *engine = _engineStack.top();

  auto js = knlohmann::json();
  js["Start Time"] = chrono::duration<double>(chrono::high_resolution_clock::now() - _startTime).count() + _cumulativeTime;

  sample._globals = &engine->_currentExperiment->_globals;
  sample.sampleLauncher();

  js["End Time"] = chrono::duration<double>(chrono::high_resolution_clock::now() - _startTime).count() + _cumulativeTime;
  js["Current Generation"] = engine->_currentExperiment->_currentGeneration;
  js["Solver Id"] = engine->_currentExperiment->_experimentId;
  __profiler["Timelines"]["Worker 0"] += js;
}

void Sequential::broadcastGlobals(std::string key, knlohmann::json &globalsJs)
{
  Engine *engine = _engineStack.top();
  engine->_currentExperiment->_globals[key] = globalsJs;
}

void Sequential::checkUpdates()
{
 KORALI_LOG_ERROR("Detected request for update in Sequential Conduit -- This provokes a deadlock. Check whether the module is properly programmed.");
}

void Sequential::sendUpdate(knlohmann::json& update)
{
 // Getting Engine pointer
 Engine *engine = _engineStack.top();

 // Getting sample id
 size_t sampleId = update["Sample Id"].get<size_t>();

 // Getting necessary sample pointer
 Sample* sample = engine->_sampleIdToPointerMap[sampleId];

 // Pushing sample JSON information to its message queue directly.
 sample->_messageQueue.push(update);
}

} // namespace conduit

} // namespace korali
