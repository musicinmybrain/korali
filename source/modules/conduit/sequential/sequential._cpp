#include "engine.hpp"
#include "modules/conduit/sequential/sequential.hpp"
#include "modules/experiment/experiment.hpp"
#include "modules/problem/problem.hpp"
#include "modules/solver/solver.hpp"
#include "sample/sample.hpp"
#include <fcntl.h>
#include <sched.h>
#include <sys/types.h>
#include <sys/wait.h>

using namespace std;

namespace korali
{
namespace conduit
{
/**
* @brief Temporary storage to hold the pointer to the current conduit
*/
Sequential *_currentConduit;

void _workerWrapper()
{
  _currentConduit->worker();
}

void Sequential::initialize()
{
  _workerQueue.push(0);
}

void Sequential::finalize()
{
  co_delete(_workerThread);
}

void Sequential::initServer()
{
  _currentConduit = this;
  _workerThread = co_create(1 << 28, _workerWrapper);
}

void Sequential::broadcastMessageToWorkers(knlohmann::json &message)
{
  // Queueing outgoing message directly
  _inputMessageQueue.push(message);
  co_switch(_workerThread);
}

void Sequential::sendMessageToEngine(knlohmann::json &message)
{
  // Queueing outgoing message directly
  _outputMessageQueue.push(message);
}

knlohmann::json Sequential::recvMessageFromEngine()
{
  Engine *engine = _engineStack.top();

  // While there's no message, keep executing sample until there is
  while (_inputMessageQueue.empty())
    co_switch(engine->_currentExperiment->_thread);

  // Pulling message from incoming message queue
  auto message = _inputMessageQueue.front();
  _inputMessageQueue.pop();

  return message;
}

knlohmann::json Sequential::recvMessageFromSample(Sample &sample)
{
  // While there's no message, keep executing sample until there is
  while (_outputMessageQueue.empty())
    co_switch(_workerThread);

  // Pulling message from outgoing message queue
  auto message = _outputMessageQueue.front();
  _outputMessageQueue.pop();

  return message;
}

void Sequential::sendMessageToSample(Sample &sample, knlohmann::json &message)
{
  // Queueing incomping message directly
  _inputMessageQueue.push(message);

  co_switch(_workerThread);
}

void Sequential::stackEngine(Engine *engine)
{
  // (Engine-Side) Adding engine to the stack to support Korali-in-Korali execution
  _engineStack.push(engine);
}

void Sequential::popEngine()
{
  // (Engine-Side) Removing the current engine to the conduit's engine stack
  _engineStack.pop();
}

bool Sequential::isRoot()
{
  return true;
}

} // namespace conduit

} // namespace korali
