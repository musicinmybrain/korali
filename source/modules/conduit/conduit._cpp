#include "engine.hpp"
#include "modules/conduit/conduit.hpp"
#include "modules/experiment/experiment.hpp"
#include "sample/sample.hpp"
#include <chrono>

using namespace std;

namespace korali
{
/**
* @brief Temporary storage to hold the pointer to the current sample to process
*/
Sample *_currentSample;

void Conduit::coroutineWrapper()
{
  Engine *engine = _engineStack.top();
  Sample *sample = _currentSample;

  (*sample)["Experiment Id"] = engine->_currentExperiment->_experimentId;
  (*sample)["Current Generation"] = engine->_currentExperiment->_currentGeneration;

  while (engine->_conduit->_workerQueue.empty())
  {
    sample->_state = SampleState::waiting;
    co_switch(engine->_currentExperiment->_thread);
  }
  sample->_workerId = engine->_conduit->_workerQueue.front();
  engine->_conduit->_workerQueue.pop();

  auto timelineJs = knlohmann::json();
  timelineJs["Start Time"] = chrono::duration<double>(chrono::high_resolution_clock::now() - _startTime).count() + _cumulativeTime;

  // Sending sample information to worker
  auto sampleJs = sample->_js.getJson();
  sampleJs["Conduit Action"] = "Process Sample";
  engine->_conduit->sendMessageToSample(*sample, sampleJs);

  // Receiving sample information from worker
  sample->_js.getJson() = engine->_conduit->recvMessageFromSample(*sample);
  engine->_conduit->_workerQueue.push(sample->_workerId);

  timelineJs["End Time"] = chrono::duration<double>(chrono::high_resolution_clock::now() - _startTime).count() + _cumulativeTime;
  timelineJs["Solver Id"] = engine->_currentExperiment->_experimentId;
  timelineJs["Current Generation"] = engine->_currentExperiment->_currentGeneration;
  __profiler["Timelines"]["Worker " + to_string(sample->_workerId)] += timelineJs;

  sample->_state = SampleState::finished;
  co_switch(engine->_currentExperiment->_thread);

  if (sample->_state != SampleState::uninitialized) KORALI_LOG_ERROR("Resuming a finished sample\n");
}

void Conduit::worker()
{
  while (true)
  {
    auto js = recvMessageFromEngine();

    if (js["Conduit Action"] == "Terminate") exit(0);
    if (js["Conduit Action"] == "Process Sample") workerProcessSample(js);
    if (js["Conduit Action"] == "Broadcast Globals") workerBroadcastGlobals(js);
    if (js["Conduit Action"] == "Stack Engine") workerStackEngine(js);
    if (js["Conduit Action"] == "Pop Engine") workerPopEngine();
  }
}

void Conduit::workerProcessSample(const knlohmann::json &js)
{
 Engine *engine = _engineStack.top();
 auto expId = js["Experiment Id"];
 Sample s;
 s._globals = &engine->_experimentVector[expId]->_globals;
 s._js.getJson() = js;
 s.sampleLauncher();
 sendMessageToEngine(s._js.getJson());
}

void Conduit::workerBroadcastGlobals(const knlohmann::json &js)
{
 Engine *engine = _engineStack.top();
 auto expId = js["Experiment Id"];
 auto key = js["Globals"]["Key"].get<std::string>();
 engine->_experimentVector[expId]->_globals[key] = js["Globals"]["Values"];
}

void Conduit::workerStackEngine(const knlohmann::json &js)
{
  auto k = new Engine;

  for (size_t i = 0; i < js["Engine"]["Experiment Vector"].size(); i++)
  {
    auto e = new Experiment;
    e->_js.getJson() = js["Engine"]["Experiment Vector"][i];
    k->_experimentVector.push_back(e);
  }

  k->initialize();

  _engineStack.push(k);
}

void Conduit::workerPopEngine()
{
 Engine *engine = _engineStack.top();
 _engineStack.pop();

 for (size_t i = 0; i < engine->_experimentVector.size(); i ++)
 {
  delete engine->_experimentVector[i]->_logger;
  delete engine->_experimentVector[i]->_solver;
  delete engine->_experimentVector[i]->_problem;
  for (size_t i = 0; i < engine->_experimentVector[i]->_variables.size(); i++) delete engine->_experimentVector[i]->_variables[i];
  delete engine->_experimentVector[i];
 }
 delete engine;
}

void Conduit::updateGlobals(std::string key, knlohmann::json &globalsJs)
{
  // Run broadcast only if this is the master process
  if (!isRoot()) return;

  Engine *engine = _engineStack.top();

  knlohmann::json js;
  js["Experiment Id"] = engine->_currentExperiment->_experimentId;
  js["Conduit Action"] = "Broadcast Globals";
  js["Globals"]["Key"] = key;
  js["Globals"]["Values"] = globalsJs;

  broadcastMessageToWorkers(js);
}

void Conduit::start(Sample &sample)
{
  // Checking if sample id was defined
  KORALI_GET(size_t, sample, "Sample Id");

  if (sample._state != SampleState::uninitialized) KORALI_LOG_ERROR("Sample has already been initialized.\n");

  if (sample._isAllocated == false)
    sample._sampleThread = co_create(1 << 28, Conduit::coroutineWrapper);
  else
    KORALI_LOG_ERROR("Sample thread is already allocated; has it executed before being re-started?\n");

  sample._state = SampleState::initialized;
  _currentSample = &sample;

  co_switch(sample._sampleThread);
}

void Conduit::wait(Sample &sample)
{
  Engine *engine = _engineStack.top();

  while (sample._state == SampleState::waiting || sample._state == SampleState::initialized)
  {
    // Check for error signals from python
    if (isPythonActive && PyErr_CheckSignals() != 0) KORALI_LOG_ERROR("User requested break.\n");

    sample._state = SampleState::running;
    co_switch(sample._sampleThread);

    if (sample._state != SampleState::finished) sample._state = SampleState::waiting;

    if (sample._state == SampleState::waiting || sample._state == SampleState::initialized) co_switch(engine->_thread);
  }

  size_t sampleId = KORALI_GET(size_t, sample, "Sample Id");

  engine->_currentExperiment->_sampleInfo["Samples"][sampleId] = sample._js.getJson();
  if (sample._isAllocated == true)
  {
    free(sample._sampleThread);
    sample._isAllocated = false;
  }
  sample._state = SampleState::uninitialized;
  co_delete(sample._sampleThread);
}

size_t Conduit::waitAny(vector<Sample> &samples)
{
  Engine *engine = _engineStack.top();
  bool isFinished = false;
  size_t currentSample;

  while (isFinished == false)
  {
    // Check for error signals from python
    if (isPythonActive && PyErr_CheckSignals() != 0) throw pybind11::error_already_set();

    for (currentSample = 0; currentSample < samples.size(); currentSample++)
    {
      if (samples[currentSample]._state == SampleState::waiting || samples[currentSample]._state == SampleState::initialized)
      {
        samples[currentSample]._state = SampleState::running;
        co_switch(samples[currentSample]._sampleThread);
        if (samples[currentSample]._state != SampleState::finished) samples[currentSample]._state = SampleState::waiting;
      }

      if (samples[currentSample]._state == SampleState::finished)
      {
        auto sampleId = KORALI_GET(size_t, samples[currentSample], "Sample Id");

        engine->_currentExperiment->_sampleInfo["Samples"][sampleId] = samples[currentSample]._js.getJson();
        if (samples[currentSample]._isAllocated == true)
        {
          free(samples[currentSample]._sampleThread);
          samples[currentSample]._isAllocated = false;
        }
        samples[currentSample]._state = SampleState::uninitialized;
        co_delete(samples[currentSample]._sampleThread);
        isFinished = true;
        break;
      }
    }

    if (isFinished == false) co_switch(engine->_thread);
  }

  return currentSample;
}

void Conduit::waitAll(vector<Sample> &samples)
{
  Engine *engine = _engineStack.top();
  bool isFinished = false;

  while (isFinished == false)
  {
    // Check for error signals from python
    if (isPythonActive && PyErr_CheckSignals() != 0) KORALI_LOG_ERROR("User requested break.\n");

    isFinished = true;

    for (size_t i = 0; i < samples.size(); i++)
      if (samples[i]._state == SampleState::waiting || samples[i]._state == SampleState::initialized)
      {
        isFinished = false;
        samples[i]._state = SampleState::running;
        co_switch(samples[i]._sampleThread);

        if (samples[i]._state != SampleState::finished) samples[i]._state = SampleState::waiting;
      }

    if (isFinished == false) co_switch(engine->_thread);
  }

  for (size_t i = 0; i < samples.size(); i++)
  {
    auto sampleId = KORALI_GET(size_t, samples[i], "Sample Id");

    engine->_currentExperiment->_sampleInfo["Samples"][sampleId] = samples[i]._js.getJson();
    if (samples[i]._isAllocated == true)
    {
      free(samples[i]._sampleThread);
      samples[i]._isAllocated = false;
    }
    samples[i]._state = SampleState::uninitialized;
    co_delete(samples[i]._sampleThread);
  }
}

} // namespace korali
