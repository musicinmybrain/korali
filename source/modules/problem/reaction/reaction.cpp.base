#include "modules/problem/reaction/reaction.hpp"
#include "sample/sample.hpp"

__startNamespace__;

void __className__::initialize()
{
  if (_k->_variables.size() == 0) KORALI_LOG_ERROR("Reaction problems require at least one variable.\n");

  for (size_t idx = 0; idx < _k->_variables.size(); ++idx)
  {
    _reactantNameToIndexMap[_k->_variables[idx]->_name] = idx;
    _initialReactantNumbers.push_back(_k->_variables[idx]->_initialReactantNumber);
  }

  // Parsing user-defined reactions
  for (size_t i = 0; i < _reactions.size(); i++)
  {
    double rate = _reactions[i]["Rate"].get<double>();
    std::string eq = _reactions[i]["Equation"];

    auto reaction = parseReactionString(eq);
    std::vector<int> reactantIds, productIds;
    for (auto &name : reaction.reactantNames)
      reactantIds.push_back(_reactantNameToIndexMap[name]);
    for (auto &name : reaction.productNames)
      productIds.push_back(_reactantNameToIndexMap[name]);

    _reactionVector.emplace_back(rate,
                                 std::move(reactantIds),
                                 std::move(reaction.reactantSCs),
                                 std::move(productIds),
                                 std::move(reaction.productSCs),
                                 std::move(reaction.isReactantReservoir));
  }
}

double __className__::computePropensity(size_t reactionIndex, const std::vector<int> &reactantNumbers) const
{
  // Get reaction
  const auto &reaction = _reactionVector[reactionIndex];

  double propensity = reaction.rate;

  for (size_t s = 0; s < reaction.reactantIds.size(); ++s)
  {
    const int nu = reaction.reactantStoichiometries[s];
    const int x = reactantNumbers[reaction.reactantIds[s]];

    int numerator = x;
    int denominator = nu;

    for (int k = 1; k < nu; ++k)
    {
      numerator *= x - k;
      denominator *= k;
    }

    propensity *= (double)numerator / denominator;
  }

  return propensity;
}

double __className__::computeGradPropensity(size_t reactionIndex, const std::vector<int>& reactantNumbers, size_t dI) const
{
    // Get reaction
    const auto &reaction = _reactionVector[reactionIndex];
   
    // Init gradient of propensity 
    double dadxi = reaction.rate;

    for (size_t s = 0; s < reaction.reactantIds.size(); ++s)
    {
        const size_t is = reaction.reactantIds[s];
        const int nu = reaction.reactantStoichiometries[s];
        const int x = reactantNumbers[is];

        double numerator = 0.;
        double denominator = 0.;
        
        if (dI == is)
        {
            // Gradient of reactant wrt itself
            denominator = nu;

            for (int k = 0; k < nu; ++k)
            {
                int partialNumerator = 1;
                for (int j = 0; j < nu; ++j)
                {
                    if (j != k)
                        partialNumerator *= x - j;
                }
                denominator *= std::max(1, k);
                numerator += partialNumerator;
            }
        }
        else
        {
            // Gradient of reactant wrt other
            numerator   = x;
            denominator = nu;

            for (int k = 1; k < nu; ++k)
            {
                numerator   *= x - k;
                denominator *= k;
            }
        }
        
        // update gradient
        dadxi *= numerator / denominator;
    }
    
    return dadxi;
}


double __className__::computeF(size_t reactionIndex, size_t otherReactionIndex, const std::vector<int> &reactantNumbers) const
{
  // TODO
  return 0.;
}


double __className__::calculateMaximumAllowedFirings(size_t reactionIndex, const std::vector<int> &reactantNumbers) const
{
 // TODO
 return 0.;
}


void __className__::applyChanges(size_t reactionIndex, std::vector<int> &reactantNumbers, int numFirings) const
{
  const auto &reaction = _reactionVector[reactionIndex];

  for (size_t s = 0; s < reaction.reactantIds.size(); ++s)
  {
    if (!reaction.isReactantReservoir[s])
      reactantNumbers[reaction.reactantIds[s]] -= numFirings * reaction.reactantStoichiometries[s];
  }

  for (size_t s = 0; s < reaction.productIds.size(); ++s)
  {
    reactantNumbers[reaction.productIds[s]] += numFirings * reaction.productStoichiometries[s];
  }

  int total = 0;
  for (size_t s = 0; s < reactantNumbers.size(); ++s)
  {
    total += reactantNumbers[s];
  }
}

__moduleAutoCode__;

__endNamespace__;
