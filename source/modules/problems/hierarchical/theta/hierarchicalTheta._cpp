#include "korali.hpp"
#include "auxiliars/koralimath.hpp"

void Korali::Problem::HierarchicalTheta::initialize()
{
  // Creating sub-problem JSON object from string
  nlohmann::json subProblemJson = loadJsonFromFile(_subProblem.c_str());

  // Sub-problem correctness checks
  std::string subProblemType = subProblemJson["Problem"]["Type"];
  if (subProblemType != "Bayesian Inference")
    Korali::logError("The Hierarchical Bayesian (Theta) can only accept sub-problems of type 'Bayesian Inference' but sub-Problem is of type: '%s'.\n", subProblemType.c_str());

  if (subProblemJson["Is Finished"] == false)
    Korali::logError("The Hierarchical Bayesian (Theta) requires that the subproblem has run completely, but it has not.\n");

  // Creating Psi-problem JSON object from string
  nlohmann::json psiProblemJson = loadJsonFromFile(_psiProblem.c_str());

  // Psi-problem correctness checks
  std::string psiProblemType = psiProblemJson["Problem"]["Type"];
  if (psiProblemType != "Hierarchical Bayesian (Psi)")
    Korali::logError("The Hierarchical Bayesian (Theta) can only accept a psi-problem of type 'Hierarchical Bayesian (Psi)' but psi-Problem is of type: '%s'.\n", psiProblemType.c_str());

  if (psiProblemJson["Is Finished"] == false)
    Korali::logError("The Hierarchical Bayesian (Theta) requires that the psi-problem has run completely, but it has not.\n");

  // Cross-checks
  if (psiProblemJson["Problem"]["Conditional Priors"].size() != subProblemJson["Problem"]["Variables"].size())
    Korali::logError("Sub-problem contains a different number of variables (%lu) than conditional priors in the Hierarchical Bayesian (Psi) problem (%lu).\n", psiProblemJson["Problem"]["Variables"].size(), psiProblemJson["Problem"]["Conditional Priors"].size());

  // Setting Korali problem objects
  _subProblemKorali.setConfiguration(subProblemJson["Problem"]);
  _psiProblemKorali.setConfiguration(psiProblemJson["Problem"]);

  // Loading Psi problem results
  _psiProblemPopulationSize = psiProblemJson["Solver"]["Population Size"].get<size_t>();
  for (size_t j = 0; j < _psiProblemPopulationSize; j++)
  {
    _psiProblemSampleLogLikelihoods.push_back(psiProblemJson["Solver"]["Internal"]["Sample Fitness Database"][j]);
    _psiProblemSampleLogPriors.push_back(psiProblemJson["Solver"]["Internal"]["Sample LogPrior Database"][j]);

    double expPrior = exp(_psiProblemSampleLogPriors[j]);
    if( std::isfinite(expPrior) == false )
      Korali::logError("Non finite (%lf) prior has been detected at sample %zu in subproblem.\n", expPrior, j );

    for (size_t k = 0; k < _psiProblemKorali.getVariableCount(); k++)
      _psiProblemSampleCoordinates.push_back(psiProblemJson["Solver"]["Internal"]["Sample Database"][j*_psiProblemKorali.getVariableCount() + k]);
 }

  // Loading Sub problem results
  _subProblemPopulationSize = subProblemJson["Solver"]["Population Size"].get<size_t>();
  for (size_t j = 0; j < _subProblemPopulationSize; j++)
  {
    _subProblemSampleLogLikelihoods.push_back(subProblemJson["Solver"]["Internal"]["Sample Fitness Database"][j]);
    _subProblemSampleLogPriors.push_back(subProblemJson["Solver"]["Internal"]["Sample LogPrior Database"][j]);

    double expPrior = exp(_subProblemSampleLogPriors[j]);
    if( std::isfinite(expPrior) == false )
      Korali::logError("Non finite (%lf) prior has been detected at sample %zu in subproblem.\n", expPrior, j );

    for (size_t k = 0; k < _subProblemKorali.getVariableCount(); k++)
      _subProblemSampleCoordinates.push_back(subProblemJson["Solver"]["Internal"]["Sample Database"][j*_subProblemKorali.getVariableCount() + k]);
  }

  size_t Npsi = _psiProblemKorali.getVariableCount();
  std::vector<double> psiSample;
  psiSample.resize(Npsi);

  std::vector<double> logValues;
  logValues.resize(_subProblemPopulationSize);

  size_t Ntheta = _subProblemKorali.getVariableCount();

  for (size_t i = 0; i < _psiProblemPopulationSize; i++)
  {
    for (size_t j = 0; j < Npsi; j++) psiSample[j] = _psiProblemSampleCoordinates[i*Npsi + j];

    _psiProblemKorali.updateConditionalPriors( psiSample );

    for (size_t j = 0;  j < _subProblemPopulationSize; j++)
    {
      double logConditionalPrior = 0;
      for (size_t k = 0; k < Ntheta; k++)
      {
        double theta = _subProblemSampleCoordinates[j*Ntheta + k];
        logConditionalPrior += _psiProblemKorali.getConditionalPrior(k)->getLogDensity(theta);
      }

      logValues[j] = logConditionalPrior - _subProblemSampleLogPriors[j];
    }

    double localSum = -log(_subProblemPopulationSize) + logSumExp(logValues);

    _precomputedLogDenominator.push_back( localSum );

  }
  // Initialize the subProblem
  _subProblemKorali.initialize();

  // Now inheriting Sub problem's variables
  for (size_t i = 0; i < _subProblemKorali.getVariableCount(); i++)
    _variables.push_back(_subProblemKorali.getVariable(i));

}

bool Korali::Problem::HierarchicalTheta::isTargetFeasible(double* target)
{
 for (size_t i = 0; i < _subProblemKorali.getVariableCount(); i++)
  if (isfinite(_subProblemKorali.getVariable(i)->_priorDistribution->getLogDensity(target[i])) == false) return false;
 return true;
}

void Korali::Problem::HierarchicalTheta::runModel(std::vector<double> target, size_t targetId)
{
  _subProblemKorali.runModel(target, targetId);
  _sample.assign( target.begin(), target.end() );
}

double Korali::Problem::HierarchicalTheta::evaluateTarget()
{
  double logLikelihood = 0.0;

  logLikelihood += _subProblemKorali.evaluateSample();

  size_t Npsi = _psiProblemKorali.getVariableCount();
  std::vector<double> psiSample;
  psiSample.resize(Npsi);

  std::vector<double> logValues;
  logValues.resize(_psiProblemPopulationSize);

  size_t Ntheta = _subProblemKorali.getVariableCount();

  for (size_t i = 0; i < _psiProblemPopulationSize; i++)
  {
    for (size_t j = 0; j < Npsi; j++) psiSample[j] = _psiProblemSampleCoordinates[i*Npsi + j];

    _psiProblemKorali.updateConditionalPriors( psiSample );

    double logConditionalPrior = 0.;
    for (size_t k = 0; k < Ntheta; k++)
      logConditionalPrior += _psiProblemKorali.getConditionalPrior(k)->getLogDensity( _sample[k] );

    logValues[i] = logConditionalPrior - _precomputedLogDenominator[i];
    // printf("-----> %lf --- %lf --- %lf \n",  logValues[i], logConditionalPrior, _precomputedLogDenominator[i] );
  }

  logLikelihood += -log(_psiProblemPopulationSize) + logSumExp(logValues);

  // printf("==========> %lf \n",  logLikelihood );

  return logLikelihood;
}

double Korali::Problem::HierarchicalTheta::evaluateSampleLogPrior(double* sample)
{
 double logPrior = 0.0;
 return logPrior;
}
