#include "modules/problems/bayesian/approximate/approximate.hpp"
#include "modules/engine/engine.hpp"
#include "auxiliars/koralimath.hpp"

void Korali::Problem::Bayesian::Approximate::initialize()
{
  Korali::Problem::Bayesian::Base::initialize();

  bool recognizedModel = false;
  if (_likelihoodModel == "Truncated Normal") recognizedModel = true;
  if (_likelihoodModel == "Normal") recognizedModel = true;
  if (recognizedModel == false) Korali::logError("Incorrect or no Likelihood Model selected: %s.\n", _likelihoodModel.c_str());

  if (_referenceData.size() == 0)  Korali::logError("Bayesian (%s) problems require defining reference data.\n", _likelihoodModel.c_str());
  if (_computationalVariableIndices.size() != 0) Korali::logError("Bayesian (%s) problems do not accept computational parameters.\n", _likelihoodModel.c_str() );
}

void Korali::Problem::Bayesian::Approximate::runModel(std::vector<double> target, size_t targetId)
{
  _modelData.setSample(targetId, target);
}

double Korali::Problem::Bayesian::Approximate::evaluateLogLikelihood()
{
  double logLikelihood = 0.0;

  if (_likelihoodModel == "Truncated Normal") logLikelihood = likelihoodTruncatedNormal(_modelData);
  if (_likelihoodModel == "Normal")           logLikelihood = likelihoodNormal(_modelData);

  return logLikelihood;
}

double Korali::Problem::Bayesian::Approximate::likelihoodNormal(Korali::Model& data)
{
  double mu     = data[_statisticalVariableIndices[0]];
  double sigma  = data[_statisticalVariableIndices[1]];
  double sigma2 = sigma*sigma;

  double logNormalization = 0.5 * M_SQRT2 * M_SQRTPI * sigma ;
  logNormalization = _referenceData.size() * gsl_sf_log(logNormalization);

  double ssn = 0.;
  for (auto& d : _referenceData){
    double diff = d - mu;
    ssn += diff*diff;
  }

  return -logNormalization - 0.5*ssn/sigma2;
}

double Korali::Problem::Bayesian::Approximate::likelihoodTruncatedNormal(Korali::Model& data)
{
  double a      = data[_statisticalVariableIndices[0]];
  double b      = data[_statisticalVariableIndices[1]];
  double mu     = data[_statisticalVariableIndices[2]];
  double sigma  = data[_statisticalVariableIndices[3]];
  double sigma2 = sigma*sigma;
  double an = (a-mu)/sigma;
  double bn = (b-mu)/sigma;

  if(a>b) return -Korali::Inf;

  double logNormalization = 0.5 * M_SQRT2 * M_SQRTPI * sigma * ( gsl_sf_erf(bn*M_SQRT1_2) - gsl_sf_erf(an*M_SQRT1_2) ) ;

  if( logNormalization == 0.) return -Korali::Inf;

  logNormalization = _referenceData.size() * gsl_sf_log(logNormalization);

  double ssn = 0.;
  for (auto& d : _referenceData){
    if( d>b || d<a) return -Korali::Inf;
    double diff = d - mu;
    ssn += diff*diff;
  }

  return -logNormalization - 0.5*ssn/sigma2;
}
