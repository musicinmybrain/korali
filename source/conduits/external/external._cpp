#include "conduits/external/external.hpp"
#include "engine/engine.hpp"
#include "problems/base.hpp"
#include "solvers/base.hpp"
#include <sys/wait.h>
#include <sys/types.h>

void Korali::Conduit::External::initialize()
{
 if (_concurrentJobs < 1) Korali::logError("You need to define at least 1 concurrent job(s) for external models \n");
 for (int i = 0; i < _concurrentJobs; i++) _pipeDescriptors.push_back(std::vector<int>(2));
 for (int i = 0; i < _concurrentJobs; i++) _launcherQueue.push(i);

 // Opening Inter-process communicator pipes
 for (int i = 0; i < _concurrentJobs; i++)
  if (pipe(_pipeDescriptors[i].data()) == -1) Korali::logError("Unable to create inter-process pipe. \n");
}

void Korali::Conduit::External::finalize()
{
 for (int i = 0; i < _concurrentJobs; i++)
 {
  close(_pipeDescriptors[i][1]); // Closing pipes
  close(_pipeDescriptors[i][0]); // Closing pipes
 }
}

void Korali::Conduit::External::runModel(size_t modelId, Korali::Sample& sample)
{
 while (_launcherQueue.empty()) sample.yield();

 _modelEvaluationCount++;

 int launcherId = _launcherQueue.front(); _launcherQueue.pop();

 pid_t processId = fork();

 _launcherIdToProcessIdMap[launcherId] = processId;
 _processIdMapToLauncherIdMap[processId] = launcherId;

 if (processId == 0)
 {
  _k->_models[modelId](sample);
  size_t resultSize = sample.getResult().size();
  write(_pipeDescriptors[launcherId][1], &resultSize, sizeof(size_t));
  write(_pipeDescriptors[launcherId][1], sample.getResult().data(), resultSize * sizeof(double));
  exit(0);
 }

 int flag = 0;
 while(flag == 0)
 {
  flag = waitpid(processId, &flag, WNOHANG);
  if (flag)
  {
   size_t resultSize;
   read(_pipeDescriptors[launcherId][0], &resultSize, sizeof(size_t));

   std::vector<double> resultVector(resultSize);
   read(_pipeDescriptors[launcherId][0], resultVector.data(), resultSize * sizeof(double));

   sample.setResult(resultVector);
   _launcherQueue.push(launcherId);
  }
  else sample.yield();
 }
}
