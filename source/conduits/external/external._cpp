#include "conduits/external/external.hpp"
#include "engine/engine.hpp"
#include "problems/base.hpp"
#include "solvers/base.hpp"
#include <sys/wait.h>

void Korali::Conduit::External::initialize()
{
 if (_concurrentJobs < 1) Korali::logError("You need to define at least 1 concurrent job(s) for external models \n");
 for (int i = 0; i < _concurrentJobs; i++) _pipeDescriptors.push_back(std::vector<int>(2));
 for (int i = 0; i < _concurrentJobs; i++) _launcherQueue.push(i);
}

void Korali::Conduit::External::runModel(size_t modelId, Korali::Sample& sample)
{
// while (_launcherQueue.empty()) checkProgress();

 int launcherId = _launcherQueue.front(); _launcherQueue.pop();

 // Opening Inter-process communicator pipes
 if (pipe(_pipeDescriptors[launcherId].data()) == -1) Korali::logError("Unable to create inter-process pipe. \n");

 pid_t processId = fork();

 //_launcherIdToSamplerIdMap[launcherId] = sampleId;
 _launcherIdToProcessIdMap[launcherId] = processId;
 _processIdMapToLauncherIdMap[processId] = launcherId;

 if (processId == 0)
 {
  //__korali_models[modelId](sample);
  //double evaluation = _k->_problem->evaluateTarget());

  //write(_pipeDescriptors[launcherId][1], &evaluation, sizeof(double));
  exit(0);
 }

 _modelEvaluationCount++;

}

//void Korali::Conduit::External::checkProgress()
//{
// int status;
// pid_t processId;
//
// processId = wait(&status);
// if (processId > 0)
// {
//  int launcherId = _processIdMapToLauncherIdMap[processId];
//  double evaluation = 0.0;
//  size_t sampleId = _launcherIdToSamplerIdMap[launcherId];
//  read(_pipeDescriptors[launcherId][0], &evaluation, sizeof(double));
//  _k->_solver->processEvaluation(sampleId, evaluation);
//  close(_pipeDescriptors[launcherId][1]); // Closing pipes
//  close(_pipeDescriptors[launcherId][0]); // Closing pipes
//  _launcherQueue.push(launcherId);
// }
//
//}
