#include "korali.hpp"

void Korali::Problem::HierarchicalPsi::initialize()
{
 if (_conditionalPriors.size() == 0) Korali::logError("Hierarchical Bayesian (Psi) problems require at least one conditional prior\n");

 if (_k->_constraints.size() > 0) Korali::logError("Hierarchical Bayesian (Psi) problems do not allow constraint definitions.\n");
 if (_k->_modelType != "Unassigned") Korali::logError("Hierarchical Bayesian (Psi) does not require a computational model, but one was provided.\n");
 if (_subProblems.size() < 2) Korali::logError("Hierarchical Bayesian (Psi) problem requires defining at least two executed sub-problems.\n");

 // Obtaining sub problem count and variable counts
 _subProblemCount = _subProblems.size();
 _subProblemVariablesCount = _conditionalPriors.size();

 // Creating JSON object from string
 for (size_t i = 0; i < _subProblemCount; i++){
   // std::cout << "---->" << _subProblems[i].c_str() << std::endl;
   _subProblemsJson.push_back(loadJsonFromFile(_subProblems[i].c_str()));
 }

 // Sub-problem correctness checks
 for (size_t i = 0; i < _subProblemCount; i++)
 {
  if (_subProblemsJson[i]["Problem"]["Type"] != "Bayesian Inference")
   Korali::logError("The Hierarchical Bayesian (Psi) can only accept sub-problems of type 'Bayesian Inference' but sub-Problem %lu is of type: '%s'.\n", i, _subProblemsJson[i]["Problem"]["Type"].get<std::string>().c_str());

  if (_conditionalPriors.size() != _subProblemsJson[i]["Problem"]["Variables"].size())
   Korali::logError("Sub-problem %lu contains a different number of variables (%lu) than conditional priors in the Hierarchical Bayesian (Psi) problem (%lu).\n", i, _subProblemsJson[i]["Problem"]["Variables"].size(), _conditionalPriors.size());

  if (_subProblemsJson[i]["Is Finished"] == false)
   Korali::logError("The Hierarchical Bayesian (Psi) requires that all problems have run completely, but Problem %lu has not.\n", i);
 }

 _subProblemSampleCoordinates.resize(_subProblemCount);
 _subProblemSampleLogLikelihoods.resize(_subProblemCount);
 _subProblemSampleLogPriors.resize(_subProblemCount);

 for (size_t i = 0; i < _subProblemCount; i++)
 {
  for (size_t j = 0; j < _subProblemsJson[i]["Solver"]["Internal"]["Chain Leaders LogLikelihoods"].size(); j++)
  {
   _subProblemSampleLogLikelihoods[i].push_back(_subProblemsJson[i]["Solver"]["Internal"]["Chain Leaders LogLikelihoods"][j]);
   _subProblemSampleLogPriors[i].push_back(_subProblemsJson[i]["Solver"]["Internal"]["Chain Leaders LogPriors"][j]);

   double expPrior = exp(_subProblemSampleLogPriors[i][j]);
   if( std::isfinite(expPrior) == false )
     Korali::logError("Non finite (%lf) prior has been detected at sample %zu in subproblem %zu.\n", expPrior, j, i );

   for (size_t k = 0; k < _subProblemVariablesCount; k++)
    _subProblemSampleCoordinates[i].push_back(_subProblemsJson[i]["Solver"]["Internal"]["Chain Leaders"][j*_subProblemVariablesCount + k]);
  }
 }
}

bool Korali::Problem::HierarchicalPsi::isSampleFeasible(double* sample)
{
 for (size_t i = 0; i < _variables.size(); i++)
  if (isfinite(_variables[i]->_priorDistribution->getLogDensity(sample[i])) == false) return false;
 return true;
}

void Korali::Problem::HierarchicalPsi::finalize()
{

}

Korali::Distribution::Base* Korali::Problem::HierarchicalPsi::getConditionalPrior(size_t idx)
{
 return _conditionalPriors[idx];
}

size_t Korali::Problem::HierarchicalPsi::getSampleSize()
{
 return _variables.size();
}

Korali::Variable* Korali::Problem::HierarchicalPsi::getVariable(size_t variableId)
{
 return _variables[variableId];
}

void Korali::Problem::HierarchicalPsi::updateConditionalPriors(std::vector<double> sample)
{
 // Re-configuring conditional priors given hyperparameters
  for (size_t i = 0; i < _conditionalPriors.size(); i++)
    _conditionalPriors[i]->updateConditionals(sample);
}

void Korali::Problem::HierarchicalPsi::runModel(std::vector<double> sample, size_t sampleId)
{
 updateConditionalPriors(sample);
}

double Korali::Problem::HierarchicalPsi::evaluateSampleFitness()
{
  double logLikelihood = 0.0;

  for (size_t i = 0; i < _subProblemCount; i++ )
  {
    std::vector<double> expValues( _subProblemSampleLogPriors[i].size(), 0.0 );

    for (size_t j = 0; j < _subProblemSampleLogPriors[i].size(); j++)
    {
      double logConditionalPrior = 0.0;
      for( size_t k = 0; k < _conditionalPriors.size(); k++ ){
        double xxx = _conditionalPriors[k]->getLogDensity(_subProblemSampleCoordinates[i][j*_subProblemVariablesCount + k]);
        // printf("=============> %lf  (%lf) \n", xxx, _subProblemSampleCoordinates[i][j*_subProblemVariablesCount + k] );
        logConditionalPrior += xxx;
      }
      expValues[j] = logConditionalPrior - _subProblemSampleLogPriors[i][j];
    }

    // printf("oooooo\n");
    double maxExpValues =  *std::max_element(std::begin(expValues), std::end(expValues));

    double sumExpValues = 0.0;
    for (auto& v : expValues){
      sumExpValues += exp( v - maxExpValues );
      // printf("--------------------> %lf  %lf   %lf  %lf  \n", v, maxExpValues, v - maxExpValues, exp( v - maxExpValues ));
    }

    // printf("-----> (%zu) max = %lf ---  sum = %lf ---  (%lf)  \n",i,maxExpValues,sumExpValues,   maxExpValues + log(sumExpValues)  );

    logLikelihood += maxExpValues + log(sumExpValues);
  }
   //printf("============> log-likelihood = %lf \n", logLikelihood);

 return logLikelihood;
}

double Korali::Problem::HierarchicalPsi::evaluateSampleLogPrior(double* sample)
{
 double logPrior = 0.0;
 for (size_t i = 0; i < _variables.size(); i++)
  logPrior += _variables[i]->_priorDistribution->getLogDensity(sample[i]);
 return logPrior;
}
