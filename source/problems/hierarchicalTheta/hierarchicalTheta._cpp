#include "korali.hpp"

void Korali::Problem::HierarchicalTheta::initialize()
{
 if (_k->_constraints.size() > 0) Korali::logError("Hierarchical Bayesian (Theta) problems do not allow constraint definitions.\n");

 // Creating sub-problem JSON object from string
 nlohmann::json subProblemJson = loadJsonFromFile(_subProblem.c_str());

 // Sub-problem correctness checks
 std::string subProblemType = consume(subProblemJson, { "Problem", "Type" }, KORALI_STRING);
 if (subProblemType != "Bayesian Inference")
  Korali::logError("The Hierarchical Bayesian (Theta) can only accept sub-problems of type 'Bayesian Inference' but sub-Problem is of type: '%s'.\n", subProblemType.c_str());

 if (subProblemJson["Is Finished"] == false)
  Korali::logError("The Hierarchical Bayesian (Theta) requires that the subproblem has run completely, but it has not.\n");

 // Creating Psi-problem JSON object from string
 nlohmann::json psiProblemJson = loadJsonFromFile(_psiProblem.c_str());

 // Psi-problem correctness checks
 std::string psiProblemType = consume(psiProblemJson, { "Problem", "Type" }, KORALI_STRING);
 if (psiProblemType != "Hierarchical Bayesian (Psi)")
  Korali::logError("The Hierarchical Bayesian (Theta) can only accept a psi-problem of type 'Hierarchical Bayesian (Psi)' but psi-Problem is of type: '%s'.\n", psiProblemType.c_str());

 if (psiProblemJson["Is Finished"] == false)
  Korali::logError("The Hierarchical Bayesian (Theta) requires that the psi-problem has run completely, but it has not.\n");

 // Cross-checks
 if (psiProblemJson["Problem"]["Conditional Priors"].size() != subProblemJson["Problem"]["Variables"].size())
  Korali::logError("Sub-problem contains a different number of variables (%lu) than conditional priors in the Hierarchical Bayesian (Psi) problem (%lu).\n", psiProblemJson["Problem"]["Variables"].size(), psiProblemJson["Problem"]["Conditional Priors"].size());

 // Setting Korali problem objects
 _subProblemKorali.setConfiguration(subProblemJson["Problem"]);

 // Loading Psi problem results
 size_t psiSampleCount = psiProblemJson["Solver"]["Internal"]["Database Entry Count"].get<size_t>();

 _psiProblemSampleCoordinates.resize(psiSampleCount * _psiProblemKorali.getSampleSize());
 _psiProblemSampleLogLikelihoods.resize(psiSampleCount);
 _psiProblemSampleLogPriors.resize(psiSampleCount);

 for (size_t j = 0; j < psiSampleCount; j++)
 {
  _psiProblemSampleLogLikelihoods[j] = psiProblemJson["Solver"]["Internal"]["Sample Fitness Database"][j];
  _psiProblemSampleLogPriors[j]      = psiProblemJson["Solver"]["Internal"]["Sample LogPrior Database"][j];

  double expPrior = exp(_psiProblemSampleLogPriors[j]);
  if( std::isfinite(expPrior) == false )
    Korali::logError("Non finite (%lf) prior has been detected at sample %zu in subproblem.\n", expPrior, j );

  for (size_t k = 0; k < _psiProblemKorali.getSampleSize(); k++)
   _psiProblemSampleCoordinates[j*_psiProblemKorali.getSampleSize() + k] = psiProblemJson["Solver"]["Internal"]["Sample Database"][j*_psiProblemKorali.getSampleSize() + k];
 }

 // Loading Sub problem results
 size_t subSampleCount = subProblemJson["Solver"]["Internal"]["Database Entry Count"].get<size_t>();

 _subProblemSampleCoordinates.resize(subSampleCount * _subProblemKorali.getSampleSize());
 _subProblemSampleLogLikelihoods.resize(subSampleCount);
 _subProblemSampleLogPriors.resize(subSampleCount);

 for (size_t j = 0; j < subSampleCount; j++)
 {
  _subProblemSampleLogLikelihoods[j] = subProblemJson["Solver"]["Internal"]["Sample Fitness Database"][j];
  _subProblemSampleLogPriors[j]      = subProblemJson["Solver"]["Internal"]["Sample LogPrior Database"][j];

  double expPrior = exp(_subProblemSampleLogPriors[j]);
  if( std::isfinite(expPrior) == false )
    Korali::logError("Non finite (%lf) prior has been detected at sample %zu in subproblem.\n", expPrior, j );

  for (size_t k = 0; k < _subProblemKorali.getSampleSize(); k++)
   _subProblemSampleCoordinates[j*_subProblemKorali.getSampleSize() + k] = subProblemJson["Solver"]["Internal"]["Sample Database"][j*_subProblemKorali.getSampleSize() + k];
 }

 // Initialize the subProblem
 _subProblemKorali.initialize();

 // Now inheriting Psi problem's variables
 for (size_t i = 0; i < _subProblemKorali.getSampleSize(); i++)
    _variables.push_back(_subProblemKorali.getVariable(i));
}

void Korali::Problem::HierarchicalTheta::finalize()
{

}

bool Korali::Problem::HierarchicalTheta::isSampleFeasible(double* sample)
{
 for (size_t i = 0; i < _subProblemKorali.getSampleSize(); i++)
  if (isfinite(_subProblemKorali.getVariable(i)->_priorDistribution->getLogDensity(sample[i])) == false) return false;
 return true;
}

size_t Korali::Problem::HierarchicalTheta::getSampleSize()
{
 return _subProblemKorali.getSampleSize();
}

Korali::Variable* Korali::Problem::HierarchicalTheta::getVariable(size_t variableId)
{
 return _subProblemKorali.getVariable(variableId);
}

void Korali::Problem::HierarchicalTheta::runModel(std::vector<double> sample, size_t sampleId)
{
  _subProblemKorali.runModel(sample, sampleId);
}

double Korali::Problem::HierarchicalTheta::evaluateSampleFitness()
{
 double logLikelihood = 0.0;

 logLikelihood += _subProblemKorali.evaluateSampleFitness();

 return logLikelihood;
}

double Korali::Problem::HierarchicalTheta::evaluateSampleLogPrior(double* sample)
{
 double logPrior = 0.0;
 return logPrior;
}
