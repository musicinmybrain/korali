#include "problems/bayesian/inference/approximate/approximate.hpp"
#include "engine/engine.hpp"

void Korali::Problem::Bayesian::Inference::Approximate::initialize()
{
  Korali::Problem::Bayesian::Inference::Base::initialize();

  if (_referenceData.size() == 0)  Korali::logError("Bayesian (%s) problems require defining reference data.\n", _likelihoodModel.c_str());
  if (_computationalVariableIndices.size() != 0) Korali::logError("Bayesian (%s) problems do not accept computational parameters.\n", _likelihoodModel.c_str() );

  if (_likelihoodModel == "Truncated Normal") if (_statisticalVariableIndices.size() != 4) Korali::logError("Approximate Truncated Normal problems require exactly four statistical parameters.\n");
  if (_likelihoodModel == "Normal") if (_statisticalVariableIndices.size() != 2) Korali::logError("Approximate Normal problems require exactly two statistical parameters.\n");
}

void Korali::Problem::Bayesian::Inference::Approximate::evaluateLogLikelihood(Korali::Sample& sample)
{
  if (_likelihoodModel == "Truncated Normal") likelihoodTruncatedNormal(sample);
  if (_likelihoodModel == "Normal")           likelihoodNormal(sample);
}

void Korali::Problem::Bayesian::Inference::Approximate::likelihoodNormal(Korali::Sample& sample)
{
  double mu     = sample[_statisticalVariableIndices[0]];
  double sigma  = sample[_statisticalVariableIndices[1]];
  double sigma2 = sigma*sigma;

  double logNormalization = 0.5 * M_SQRT2 * M_SQRTPI * sigma;

  if( logNormalization <= 0.) { sample.setResult(-Korali::Inf); return; }

  logNormalization = _referenceData.size() * gsl_sf_log(logNormalization);

  double ssn = 0.;
  for (auto& d : _referenceData){
    double diff = d - mu;
    ssn += diff*diff;
  }

  sample.setResult(-logNormalization - 0.5*ssn/sigma2);
}

void Korali::Problem::Bayesian::Inference::Approximate::likelihoodTruncatedNormal(Korali::Sample& sample)
{
  double a      = sample[_statisticalVariableIndices[0]];
  double b      = sample[_statisticalVariableIndices[1]];
  double mu     = sample[_statisticalVariableIndices[2]];
  double sigma  = sample[_statisticalVariableIndices[3]];
  double sigma2 = sigma*sigma;
  double an = (a-mu)/sigma;
  double bn = (b-mu)/sigma;

  if(a>b) { sample.setResult(-Korali::Inf); return; };


  double logNormalization = 0.5 * M_SQRT2 * M_SQRTPI * sigma * ( gsl_sf_erf(bn*M_SQRT1_2) - gsl_sf_erf(an*M_SQRT1_2) ) ;

  if( logNormalization <= 0.) { sample.setResult(-Korali::Inf); return; }

  logNormalization = _referenceData.size() * gsl_sf_log(logNormalization);

  double ssn = 0.;
  for (auto& d : _referenceData){
    if( d>b || d<a) { sample.setResult(-Korali::Inf); return; };
    double diff = d - mu;
    ssn += diff*diff;
  }

  sample.setResult(-logNormalization - 0.5*ssn/sigma2);
}
