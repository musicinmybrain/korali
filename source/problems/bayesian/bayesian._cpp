#include "korali.hpp"

void Korali::Problem::Bayesian::initialize()
{
 if (_variables.size() == 0) Korali::logError("Bayesian inference problems require at least one variable.\n");

 bool recognizedModel = false;
 if (_likelihoodModel == "Custom") recognizedModel = true;
 if (_likelihoodModel == "Additive Normal") recognizedModel = true;
 if (_likelihoodModel == "Multiplicative Normal") recognizedModel = true;
 if (_likelihoodModel == "Multiplicative Normal Data") recognizedModel = true;
 if (recognizedModel == false) Korali::logError("Incorrect or no Likelihood Model selected: %s.\n", _likelihoodModel.c_str());

 _computationalVariableIndices.clear();
 _statisticalVariableIndices.clear();
 for (size_t i = 0; i < _variables.size(); i++)
 {
   std::string typeString = _variables[i]->_type;
   bool recognizedType = false;
   if (typeString == "Computational") { _computationalVariableIndices.push_back(i); recognizedType = true; }
   if (typeString == "Statistical")   { _statisticalVariableIndices.push_back(i); recognizedType = true; }
   if (recognizedType == false) Korali::logError("Incorrect Bayesian variable type selected: %s.\n", typeString.c_str());
 }

 if (_k->_constraints.size() > 0) Korali::logError("Bayesian inference problems do not allow constraint definitions.\n");

 if (_likelihoodModel == "Additive Normal" || _likelihoodModel == "Multiplicative Normal" || _likelihoodModel == "Multiplicative Normal Data")
 {
   if (_likelihoodReferenceData.size() == 0) Korali::logError("Bayesian (%s) problems require defining reference data.\n", _likelihoodModel.c_str());
   if (_k->_modelType != "Reference") Korali::logError("Bayesian (%s) problems require defining a refererence computational model. Used: %s\n", _likelihoodModel.c_str(), _k->_modelType.c_str());
   if (_statisticalVariableIndices.size() != 1) Korali::logError("Bayesian (%s) problems require exactly 1 statistical parameter, provided: %lu.\n", _likelihoodModel.c_str(), _statisticalVariableIndices.size());
 }

 if (_likelihoodModel == "Custom")
 {
   if (_likelihoodReferenceData.size() != 0) Korali::logError("Bayesian (Custom) problems do not accept reference data.\n");
   if (_k->_modelType != "Likelihood") Korali::logError("Bayesian (Custom) problems require defining a likelihood computational model. Used: %s\n", _likelihoodModel.c_str(), _k->_modelType.c_str());
   if (_statisticalVariableIndices.size() != 0) Korali::logError("Bayesian (Custom) problems do not accept statistical variables.\n");
 }
}

void Korali::Problem::Bayesian::finalize()
{

}

bool Korali::Problem::Bayesian::isSampleFeasible(double* sample)
{
 for (size_t i = 0; i < _variables.size(); i++)
  if (isfinite(_variables[i]->_priorDistribution->getLogDensity(sample[i])) == false) return false;
 return true;
}

size_t Korali::Problem::Bayesian::getVariableCount()
{
 return _variables.size();
}

Korali::Variable* Korali::Problem::Bayesian::getVariable(size_t variableId)
{
 return _variables[variableId];
}

void Korali::Problem::Bayesian::runModel(std::vector<double> sample, size_t sampleId)
{
 if (_likelihoodModel == "Additive Normal" || _likelihoodModel == "Multiplicative Normal" || _likelihoodModel == "Multiplicative Normal Data")
 {
  // Creating model data.
  _referenceModelData._evaluations.clear();
  _referenceModelData._sampleId = sampleId;
  _referenceModelData._variables = sample;

  // Executing Model
  _k->_referenceModel(_referenceModelData);
 }

 if (_likelihoodModel == "Custom")
 {
  // Creating model data.
  _likelihoodModelData._sampleId = sampleId;
  _likelihoodModelData._variables = sample;

  // Executing Model
  _k->_likelihoodModel(_likelihoodModelData);
 }
}

double Korali::Problem::Bayesian::evaluateSampleFitness()
{
 double fitness = 0.0;

 if (_likelihoodModel == "Additive Normal" || _likelihoodModel == "Multiplicative Normal" || _likelihoodModel == "Multiplicative Normal Data")
 {
  if (_referenceModelData._evaluations.size() != _likelihoodReferenceData.size())
     Korali::logError("Bayesian (%s) problems require a %lu-sized reference result array. Provided: %lu.\n", _likelihoodModel.c_str(), _likelihoodReferenceData.size(), _referenceModelData._evaluations.size());

  if (_likelihoodModel == "Additive Normal")            fitness = likelihoodNormalAdditive(_referenceModelData);
  if (_likelihoodModel == "Multiplicative Normal")      fitness = likelihoodNormalMultiplicative(_referenceModelData);
  if (_likelihoodModel == "Multiplicative Normal Data") fitness = likelihoodNormalMultiplicativeData(_referenceModelData);
 }

 if (_likelihoodModel == "Custom") fitness =  _likelihoodModelData._likelihood;

 return fitness;
}

double Korali::Problem::Bayesian::evaluateSampleLogPrior(double* sample)
{
 double logPrior = 0.0;
 for (size_t i = 0; i < _variables.size(); i++)
  logPrior += _variables[i]->_priorDistribution->getLogDensity(sample[i]);
 return logPrior;
}

double Korali::Problem::Bayesian::likelihoodNormalAdditive(Korali::Model::Reference& data)
{
  double sigma   = data._variables[_statisticalVariableIndices[0]];
  double sigma2  = sigma*sigma;
  double ssn     = 0.0;
  double fitness = 0.0;

  for(size_t i = 0; i < _likelihoodReferenceData.size(); i++)
  {
    if( !isfinite(data._evaluations[i]) )
    {
      Korali::logWarning(KORALI_NORMAL,"Non-finite value detected in the results passed in the log-likelihood function.");
      return std::numeric_limits<double>::lowest();
    }
    double diff = _likelihoodReferenceData[i] - data._evaluations[i];
    ssn += diff*diff;
  }

  fitness = -0.5*( _likelihoodReferenceData.size()*log(2*M_PI) + ssn/sigma2) - _likelihoodReferenceData.size()*log(sigma);
  return fitness;
}

double Korali::Problem::Bayesian::likelihoodNormalMultiplicative(Korali::Model::Reference& data)
{
  double sigma    = data._variables[_statisticalVariableIndices[0]];
  double ssn      = 0.0;
  double fitness  = 0.0;
  double logSigma = 0.0;
  for(size_t i = 0; i < _likelihoodReferenceData.size(); i++)
  {
    if( !isfinite(data._evaluations[i]) )
    {
      Korali::logWarning(KORALI_NORMAL,"Non-finite value detected in the results passed in the log-likelihood function.");
      return std::numeric_limits<double>::lowest();
    }

    double diff   = _likelihoodReferenceData[i] - data._evaluations[i];
    double denom  = sigma*data._evaluations[i];
    ssn += diff*diff / (denom*denom);
    logSigma += log(denom);
  }

  fitness = -0.5*( _likelihoodReferenceData.size()*log(2*M_PI) + ssn) - _likelihoodReferenceData.size()*logSigma;
  return fitness;
}

double Korali::Problem::Bayesian::likelihoodNormalMultiplicativeData(Korali::Model::Reference& data)
{
  double sigma    = data._variables[_statisticalVariableIndices[0]];
  double ssn      = 0.0;
  double fitness  = 0.0;
  double logSigma = 0.0;
  for(size_t i = 0; i < _likelihoodReferenceData.size(); i++)
  {
    if( !isfinite(data._evaluations[i]) )
    {
      Korali::logWarning(KORALI_NORMAL,"Non-finite value detected in the results passed in the log-likelihood function.");
      return std::numeric_limits<double>::lowest();
    }

    double diff   = _likelihoodReferenceData[i] - data._evaluations[i];
    double denom  = sigma*_likelihoodReferenceData[i];
    ssn += diff*diff / (denom*denom);
    logSigma += log(denom);
  }

  fitness = -0.5*( _likelihoodReferenceData.size()*log(2*M_PI) + ssn) - _likelihoodReferenceData.size()*logSigma;
  return fitness;
}
