#include "korali.hpp"

void Korali::Problem::Hierarchical::initialize()
{
 if (_conditionalPriors.size() == 0) koraliError("Hierarchical Bayesian problems require at least one conditional prior\n");

 if (_k->_constraints.size() > 0) koraliError("Hierarchical Bayesian problems do not allow constraint definitions.\n");
 if (_k->_modelType != "Unassigned") koraliError("Hierarchical Bayesian does not require a computational model, but one was provided.\n");
 if (_subProblems.size() < 2) koraliError("Hierarchical Bayesian problem requires defining at least two executed sub-problems.\n");

 bool foundModel = false;
 if (_model == "Sample Psi")   foundModel = true;
 if (_model == "Sample Theta") foundModel = true;
 if (foundModel == false) koraliError("Incorrect or no model selected for Hierarchical Bayesian: %s.\n", _model.c_str());

 // Obtaining sub problem count and variable counts
 _subProblemCount = _subProblems.size();
 _subProblemVariablesCount = _conditionalPriors.size();

 // Creating JSON object from string
 for (size_t i = 0; i < _subProblemCount; i++){
   // std::cout << "---->" << _subProblems[i].c_str() << std::endl;
   _subProblemsJson.push_back(loadJsonFromFile(_subProblems[i].c_str()));
 }

 // Sub-problem correctness checks
 for (size_t i = 0; i < _subProblemCount; i++)
 {
  if (_subProblemsJson[i]["Problem"]["Type"] != "Bayesian Inference")
   koraliError("The Hierarchical Bayesian can only accept sub-problems of type 'Bayesian Inference' but sub-Problem %lu is of type: '%s'.\n", i, _subProblemsJson[i]["Problem"]["Type"].get<std::string>().c_str());

  if (_conditionalPriors.size() != _subProblemsJson[i]["Variables"].size())
   koraliError("Sub-problem %lu contains a different number of variables (%lu) than conditional priors in the Hierarchical Bayesian problem (%lu).\n", i, _subProblemsJson[i]["Problem"]["Variables"].size(), _conditionalPriors.size());

  if (_subProblemsJson[i]["Is Finished"] == false)
   koraliError("The Hierarchical Bayesian requires that all problems have run completely, but Problem %lu has not.\n", i);
 }

 _subProblemSampleCoordinates.resize(_subProblemCount);
 _subProblemSampleLogLikelihoods.resize(_subProblemCount);
 _subProblemSampleLogPriors.resize(_subProblemCount);

 for (size_t i = 0; i < _subProblemCount; i++)
 {
  size_t sampleCount = _subProblemsJson[i]["Solver"]["Internal"]["Database Entry Count"].get<size_t>();

  _subProblemSampleCoordinates[i].resize(sampleCount * _subProblemVariablesCount);
  _subProblemSampleLogLikelihoods[i].resize(sampleCount);
  _subProblemSampleLogPriors[i].resize(sampleCount);

  for (size_t j = 0; j < sampleCount; j++)
  {
   _subProblemSampleLogLikelihoods[i][j] = _subProblemsJson[i]["Solver"]["Internal"]["Sample Fitness Database"][j];
   _subProblemSampleLogPriors[i][j] = _subProblemsJson[i]["Solver"]["Internal"]["Sample Log Prior Database"][j];

   for (size_t k = 0; k < _subProblemVariablesCount; k++)
    _subProblemSampleCoordinates[i][j*_subProblemVariablesCount + k] = _subProblemsJson[i]["Solver"]["Internal"]["Sample Parameters Database"][j*_subProblemVariablesCount + k];
  }
 }
}

void Korali::Problem::Hierarchical::finalize()
{

}

void Korali::Problem::Hierarchical::runModel(std::vector<double> sample, size_t sampleId)
{
 // Re-configuring conditional priors given hyperparameters
 for (size_t i = 0; i < _conditionalPriors.size(); i++)
  _conditionalPriors[i]->updateConditionals(sample);
}

double Korali::Problem::Hierarchical::evaluateFitness()
{
 double logFitness = 0.0;

 double prior1, prior2;

  if( _model == "Sample Psi" )
  {
    for( size_t i = 0; i < _subProblemCount; i++ )
    {
      double localSum = 0.0;
      double tmp;
      for (size_t j = 0; j < _subProblemSampleLogLikelihoods[i].size(); j++)
      {
        // Calculating each conditional prior's logDensity for each subproblem's sample, given hyperparameters.
        prior1 = 0.0;
        for( size_t k = 0; k < _conditionalPriors.size(); k++ ){
          double xxx = _conditionalPriors[k]->getLogDensity(_subProblemSampleCoordinates[i][j*_subProblemVariablesCount + k]);
          // printf("---------->  %le  --- %le\n", _subProblemSampleCoordinates[i][j*_subProblemVariablesCount + k] , xxx);
          prior1 += xxx;
        }

        // These are hyperparameters-invariants so perhaps could be taken out of loop eventually.
        // logFitness += _subProblemSampleLogLikelihoods[i][j];
        prior2 = _subProblemSampleLogPriors[i][j];

        // printf("--->  %lf  ---  %lf\n",prior1,prior2);

        tmp = exp(prior2-prior1);

        if( std::isfinite(exp(prior2)) == false )
          koraliError("Non finite prior has been detected in the denominator of the Hierarchical likelihood. (%lf)\n", exp(prior2) );

        localSum += tmp;
      }
      printf("--->  %le\n", log(localSum));
      // if( ~isfinite(localSum) ) koraliError("Non finite term has been detected in the Hierarchical likelihood.\n");
      logFitness += log(localSum);
    }
  }

 if (_model == "Sample Theta")
 {
  // I don't know who this one works
 }

 return logFitness;
}

double Korali::Problem::Hierarchical::evaluateLogPrior(double* sample)
{
 double logPrior = 0.0;
 for (size_t i = 0; i < _k->N; i++) logPrior += _k->_variables[i]->_priorDistribution->getLogDensity(sample[i]);
 return logPrior;
}
