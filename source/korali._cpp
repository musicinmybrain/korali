#include "korali.hpp"
#include <chrono>
#include <sys/types.h>
#include <sys/stat.h>
#include <cstdio>

Korali::Engine* Korali::_k;

void Korali::Engine::getConfiguration()
{
 auto js = nlohmann::json();
 _js = js;

 _js["General"]["Random Seed"]   = _randomSeed;
 _js["General"]["Run ID"] = _runID;
 _js["General"]["Timestamp"] = _timestamp;
 _js["General"]["Current Generation"] = _currentGeneration;
 _js["General"]["Console Output"]["Verbosity"] = _consoleOutputVerbosity;
 _js["General"]["Console Output"]["Frequency"] = _consoleOutputFrequency;
 _js["General"]["Results Output"]["Frequency"] = _resultsOutputFrequency;
 _js["General"]["Results Output"]["Path"] = _resultsOutputPath;
 _js["General"]["Model Evaluation Count"] = _modelEvaluationCount;
 _js["General"]["Is Finished"] = _isFinished;

 _js["Solver"]["Type"] = _solverType;
 _js["Conduit"]["Type"] = _conduitType;
 _js["Problem"]["Type"] = _problemType;

 _problem->getConfiguration(_js["Problem"]);
 _conduit->getConfiguration(_js["Conduit"]);
 _solver->getConfiguration(_js["Solver"]);
}

void Korali::Engine::setConfiguration()
{
 auto js = _js;

 // Obtaining module selections
 _solverType = consume(_js, { "Solver", "Type" }, KORALI_STRING);
 _problemType = consume(_js, { "Problem", "Type" }, KORALI_STRING);
 _conduitType =  consume(_js, { "Conduit", "Type" }, KORALI_STRING, "Simple");

 _timestamp = consume(_js, { "General", "Timestamp" }, KORALI_STRING, "");
 _runID = consume(_js, { "General", "Run ID" }, KORALI_NUMBER, "0");
 _randomSeed  = consume(_js, { "General", "Random Seed" }, KORALI_NUMBER, "0");
 _consoleOutputVerbosity = consume(_js, { "General", "Console Output", "Verbosity" }, KORALI_STRING, "Normal");
 _resultsOutputPath = consume(_js, { "General", "Results Output", "Path" }, KORALI_STRING, "_korali_result");

 // Korali-specific configuration
 _currentGeneration = consume(_js, { "General", "Current Generation" }, KORALI_NUMBER, "0");
 _consoleOutputFrequency = consume(_js, { "General", "Console Output", "Frequency" }, KORALI_NUMBER, "1");
 _resultsOutputFrequency = consume(_js, { "General", "Results Output", "Frequency" }, KORALI_NUMBER, "1");
 _modelEvaluationCount = consume(_js, { "General", "Model Evaluation Count" }, KORALI_NUMBER, "0");
 _isFinished = consume(_js, { "General", "Is Finished" }, KORALI_BOOLEAN, "false");

 bool recognizedConduit = false;
 bool recognizedProblem = false;
 bool recognizedSolver = false;

 // Configuring Conduit
 if (recognizedConduit == false) Korali::logError("Incorrect or undefined Conduit '%s'.\n", _conduitType.c_str());
 _conduit->setConfiguration(_js["Conduit"]);

 // Configuring Problem
 if (recognizedProblem == false) Korali::logError("Incorrect or undefined Problem '%s'.\n", _problemType.c_str());
 _problem->setConfiguration(_js["Problem"]);

 // Configuring Solver
 if (recognizedSolver == false) Korali::logError("Incorrect or undefined Solver '%s'.\n", _solverType.c_str());
 _solver->setConfiguration(_js["Solver"]);

 if (isEmpty(_js) == false) Korali::logError("Unrecognized Settings for Korali:\n %s \n", _js.dump(2).c_str());
 _js = js;
}

/************************************************************************/
/*                    Functional Methods                                */
/************************************************************************/

void Korali::Engine::initialize()
{
 // Initializing Verbosity
 bool verbosityDefined = false;
 if (_consoleOutputVerbosity == "Silent")   verbosityDefined = true;
 if (_consoleOutputVerbosity == "Minimal")  verbosityDefined = true;
 if (_consoleOutputVerbosity == "Normal")   verbosityDefined = true;
 if (_consoleOutputVerbosity == "Detailed") verbosityDefined = true;
 if (verbosityDefined == false) Korali::logError("Incorrect or undefined Verbosity Level '%s'\n.", _consoleOutputVerbosity.c_str());

 // Setting Run ID, if not already defined
 if (_runID == 0)
 {
  _timestamp = "";
  time_t rawtime; time (&rawtime);
  std::string curTime(ctime(&rawtime));
  std::hash<std::string> hasher;
  _runID = hasher(_timestamp) + hasher(_solverType);
 }

 // Configuring Seed
 if (_randomSeed == 0) _randomSeed = _runID;

 // Initializing GSL
 gsl_rng_env_setup();

 // Creating Results directory
 mkdir(_resultsOutputPath.c_str(), S_IRWXU | S_IRWXG | S_IROTH | S_IXOTH);

 // Initializing Korali Components
 _problem->initialize();
 _solver->initialize();
 _conduit->initialize();
}

void Korali::Engine::setDirectModel(std::function<void(Korali::Model::Direct&)> model)
{
 _modelType = "Direct";
 _directModel = model;
}

void Korali::Engine::setLikelihoodModel(std::function<void(Korali::Model::Likelihood&)> model)
{
 _modelType = "Likelihood";
 _likelihoodModel = model;
}

void Korali::Engine::setReferenceModel(std::function<void(Korali::Model::Reference&)> model)
{
 _modelType = "Reference";
 _referenceModel = model;
}

void Korali::Engine::addConstraint(std::function<void(Korali::Model::Constraint&)> constraint)
{
 _constraints.push_back(constraint);
}

void Korali::Engine::start(bool isDryRun)
{
 _k = this;

 setConfiguration();

 initialize();

 // If this is a worker process (not root), there's nothing else to do
 if (_conduit->isRoot() == false) return;

 // If this is a dry run and configuration succeeded, print sucess and return
 if (isDryRun)
  {
   getConfiguration();
   Korali::logInfo("Minimal",  "--------------------------------------------------------------------\n");
   Korali::logInfo("Minimal",  "Dry Run Successful.\n", _currentGeneration);
   Korali::logInfo("Minimal",  "--------------------------------------------------------------------\n");
   return;
  }

 // Saving initial state
 saveState("initial.json");

 auto startTime = std::chrono::system_clock::now();

 // Running Solver by generations until at least one termination criterion is satisfied
 while(_solver->checkTermination() == false)
 {
  auto t0 = std::chrono::system_clock::now();

  _currentGeneration++;
  _solver->runGeneration();

  auto t1 = std::chrono::system_clock::now();

  if (_currentGeneration % _consoleOutputFrequency == 0)
  {
   Korali::logInfo("Minimal",  "--------------------------------------------------------------------\n");
   Korali::logInfo("Minimal",  "Generation: #%zu\n", _currentGeneration);
   Korali::logInfo("Detailed", "Generation Time: %.3fs\n", std::chrono::duration<double>(t1-t0).count());
   _solver->printGeneration();
  }

  if (_currentGeneration % _resultsOutputFrequency == 0) saveState(_currentGeneration);
 }

 // Saving last generation and final.json
 saveState(_currentGeneration);
 saveState("final.json");

 auto endTime = std::chrono::system_clock::now();

 Korali::logInfo("Minimal", "--------------------------------------------------------------------\n");
 Korali::logInfo("Minimal", "%s finished correctly.\n", _solverType.c_str(), _currentGeneration);

 _solver->finalize();
 _problem->finalize();
 _conduit->finalize();

 Korali::logInfo("Minimal", "--------------------------------------------------------------------\n");
 Korali::logInfo("Minimal", "Total Generations: %lu\n", _currentGeneration);
 Korali::logInfo("Minimal", "Total Computational Model Evaluations: %lu\n", _modelEvaluationCount);
 Korali::logInfo("Minimal", "Elapsed Time: %.3fs\n", std::chrono::duration<double>(endTime-startTime).count());
 Korali::logInfo("Minimal", "Results saved to folder: '%s'\n", _resultsOutputPath.c_str());
}

void Korali::Engine::saveState(std::string fileName)
{
 // Updating run timestamp
 time_t rawtime; time (&rawtime);
 std::string curTime(ctime(&rawtime));
 _timestamp = curTime.substr(0, curTime.size()-1);

 // Updating configuration
 getConfiguration();

 // Only the root rank saves files
 if (!_conduit->isRoot()) return;
 fileName = "./" + _resultsOutputPath + "/" + fileName;
 saveJsonToFile(fileName.c_str(), _js);
}

void Korali::Engine::saveState(int fileId)
{
 if (!_conduit->isRoot()) return;

 char fileName[256];

 sprintf(fileName, "s%05d.json", fileId);

 saveState(fileName);
}

void Korali::Engine::loadState(std::string fileName)
{
 _js = loadJsonFromFile(fileName.c_str());
}
