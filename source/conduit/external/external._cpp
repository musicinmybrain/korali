#include "conduit/external/external.hpp"
#include "engine/engine.hpp"
#include "problem/problem.hpp"
#include "solver/solver.hpp"
#include <sys/wait.h>
#include <sys/types.h>
#include <fcntl.h>

void korali::conduit::External::initialize()
{
 korali::Conduit::initialize();

 if (_concurrentJobs < 1) korali::logError("You need to define at least 1 concurrent job(s) for external models \n");
 for (int i = 0; i < _concurrentJobs; i++) _pipeDescriptors.push_back(std::vector<int>(2));
 for (int i = 0; i < _concurrentJobs; i++) _launcherQueue.push(i);

 // Opening Inter-process communicator pipes
 for (int i = 0; i < _concurrentJobs; i++)
 {
  if (pipe(_pipeDescriptors[i].data()) == -1) korali::logError("Unable to create inter-process pipe. \n");
  int retval;
  retval = fcntl(_pipeDescriptors[i][0], F_SETFL, fcntl(_pipeDescriptors[i][0], F_GETFL) | O_NONBLOCK | O_RDONLY);
  printf("Ret from 0 fcntl: %d\n", retval);
  retval = fcntl(_pipeDescriptors[i][1], F_SETFL, fcntl(_pipeDescriptors[i][1], F_GETFL) | O_NONBLOCK | O_WRONLY);
  printf("Ret from 1 fcntl: %d\n", retval);
 }
}

void korali::conduit::External::finalize()
{
 for (int i = 0; i < _concurrentJobs; i++)
 {
  close(_pipeDescriptors[i][1]); // Closing pipes
  close(_pipeDescriptors[i][0]); // Closing pipes
 }

 korali::Conduit::finalize();
}

void korali::conduit::External::processSample(korali::Sample& sample)
{
 _modelEvaluationCount++;

 while (_launcherQueue.empty())
 {
  sample._state = SampleState::waiting;
  co_switch(__conduit->_mainThread);
 }

 int launcherId = _launcherQueue.front(); _launcherQueue.pop();

 pid_t processId = fork();

 _launcherIdToProcessIdMap[launcherId] = processId;
 _processIdMapToLauncherIdMap[processId] = launcherId;

 if (processId == 0)
 {
  _k->_problem->runOperation(sample["Operation"], sample);

  std::string resultJsonString = sample._js.getJson().dump();
  size_t resultJsonSize = resultJsonString.size();

  write(_pipeDescriptors[launcherId][1], &resultJsonSize, sizeof(size_t));
  write(_pipeDescriptors[launcherId][1], resultJsonString.c_str(), resultJsonSize * sizeof(char));
  exit(0);
 }

 _profileInfo["Conduit " + std::to_string(launcherId)].startSegment(sample["Sample Id"]);

 int readBytes = -1;
 while(readBytes < 0)
 {
  size_t resultJsonSize;
  readBytes = read(_pipeDescriptors[launcherId][0], &resultJsonSize, sizeof(size_t));

  if(readBytes > 0)
  {
   char resultStringChar[resultJsonSize + 1];
   while(read(_pipeDescriptors[launcherId][0], resultStringChar, resultJsonSize * sizeof(char)) < 0);

   resultStringChar[resultJsonSize] = '\0';
   sample._js.getJson() = nlohmann::json::parse(resultStringChar);

   _launcherQueue.push(launcherId);
  }
  else
  {
   sample._state = SampleState::waiting;
   co_switch(__conduit->_mainThread);
  }
 }

 _profileInfo["Conduit " + std::to_string(launcherId)].commitSegment();
}
