#include "conduit/conduit.hpp"

korali::Conduit* korali::__conduit;

void korali::Conduit::initialize()
{
 __conduit = this;
}

void korali::Conduit::coroutineWrapper()
{
 korali::Sample* currentSample = __conduit->_currentSample;
 co_switch(_currentSolver->_thread);
 (*currentSample)["Job Id"] = _currentSolver->_solverId;

 __conduit->processSample(*currentSample);

 currentSample->_state = SampleState::finished;
 co_switch(_currentSolver->_thread);

 if (currentSample->_state != SampleState::uninitialized) korali::logError("Resuming a finished sample\n");
}

void korali::Conduit::start(korali::Sample& sample)
{
 if (sample._state != SampleState::uninitialized) korali::logError("Sample has already been initialized.\n");

 sample._sampleThread = co_create(8192*sizeof(void*), korali::Conduit::coroutineWrapper);
 sample._state = SampleState::initialized;
 __conduit->_currentSample = &sample;
 co_switch(sample._sampleThread);
}

void korali::Conduit::wait(korali::Sample& sample)
{
 __profiler["Main Thread"]["Timestamps"] += std::chrono::duration<double>(std::chrono::high_resolution_clock::now()-_startTime).count();
 __profiler["Main Thread"]["Segment Id"] += -1;

 while(sample._state == SampleState::waiting || sample._state == SampleState::initialized)
 {
  sample._state = SampleState::running;
  co_switch(sample._sampleThread);

  if (sample._state == SampleState::waiting || sample._state == SampleState::initialized) co_switch(__conduit->_k->_thread);
 }

 free(sample._sampleThread);
 sample._state = SampleState::uninitialized;

 __profiler["Main Thread"]["Timestamps"] += std::chrono::duration<double>(std::chrono::high_resolution_clock::now()-_startTime).count();
 __profiler["Main Thread"]["Segment Id"] += _currentSolver->_solverId;
}

size_t korali::Conduit::waitAny(std::vector<korali::Sample>& samples)
{
 bool isFinished = false;
 size_t currentSample;

 __profiler["Main Thread"]["Timestamps"] += std::chrono::duration<double>(std::chrono::high_resolution_clock::now()-_startTime).count();
 __profiler["Main Thread"]["Segment Id"] += -1;

 while (isFinished == false)
 {
  for (currentSample = 0; currentSample < samples.size(); currentSample++)
  {
   if (samples[currentSample]._state == SampleState::waiting || samples[currentSample]._state == SampleState::initialized)
   {
    samples[currentSample]._state = SampleState::running;
    co_switch(samples[currentSample]._sampleThread);
   }

   if (samples[currentSample]._state == SampleState::finished)
   {
    free(samples[currentSample]._sampleThread);
    samples[currentSample]._state = SampleState::uninitialized;
    isFinished = true;
    break;
   }
  }

  if (isFinished == false) co_switch(__conduit->_k->_thread);
 }

 __profiler["Main Thread"]["Timestamps"] += std::chrono::duration<double>(std::chrono::high_resolution_clock::now()-_startTime).count();
 __profiler["Main Thread"]["Segment Id"] += _currentSolver->_solverId;

 return currentSample;
}

void korali::Conduit::waitAll(std::vector<korali::Sample>& samples)
{
 bool isFinished = false;

 __profiler["Main Thread"]["Timestamps"] += std::chrono::duration<double>(std::chrono::high_resolution_clock::now()-_startTime).count();
 __profiler["Main Thread"]["Segment Id"] += -1;

 while (isFinished == false)
 {
  isFinished = true;

  for (size_t i = 0; i < samples.size(); i++)
   if (samples[i]._state == SampleState::waiting || samples[i]._state == SampleState::initialized)
   {
    isFinished = false;
    samples[i]._state = SampleState::running;
    co_switch(samples[i]._sampleThread);
   }

  if (isFinished == false) co_switch(__conduit->_k->_thread);
 }

 for (size_t i = 0; i < samples.size(); i++)
 {
  free(samples[i]._sampleThread);
  samples[i]._state = SampleState::uninitialized;
 }

 __profiler["Main Thread"]["Timestamps"] += std::chrono::duration<double>(std::chrono::high_resolution_clock::now()-_startTime).count();
 __profiler["Main Thread"]["Segment Id"] += _currentSolver->_solverId;
}
