#ifndef __KORALI_SAMPLE_HPP_
#define __KORALI_SAMPLE_HPP_

#include <vector>
#include <functional>
#include "auxiliar/logger.hpp"
#include "module.hpp"
#include "sample/libco/libco.h"
#include <string>
#include <vector>
#include <map>

namespace korali
{

enum class SampleState { uninitialized, initialized, waiting, finished };

class Sample : public korali::Module {

 private:

 Sample* _self;
 SampleState _state;
 cothread_t _mainThread;
 cothread_t _terminationThread;
 cothread_t _sampleThread;
 std::function<void(korali::Sample&)> _function;

 public:

 std::map<std::string, std::vector<double>> _data;

 bool _hasProgressed;

 Sample(const std::vector<double>& sampleData);
 Sample();

 // Sample Setting Functions
 size_t getSampleId() { return _self->_sampleId; }
 void setSampleId(size_t sampleId) { _self->_sampleId = sampleId; }

 std::vector<double>& getSampleData() { return _self->_sampleData; }

 double& operator[](size_t i)
 {
  if (i >= _self->_sampleData.size())
   korali::logError("Requesting index %lu, but the sample contains only %lu values.\n", i, _self->_sampleData.size());
  return _self->_sampleData[i];
 }

 void operator=(const std::vector<double>& sampleData) { _self->_sampleData = sampleData; }
 size_t size(){ return _self->_sampleData.size(); }

 // Result Functions
 std::vector<double>& getResult() { return _self->_result; }
 void setResult(const double& result) { _self->_result.clear(); _self->_result.push_back(result); }
 void setResult(const std::vector<double>& results) { _self->_result = results; }

 // Execution Control Functions
 void start(std::function<void(korali::Sample&)> func);

 void resume();
 void yield();
 void wait();
 static void threadCallWrapper();
 static void terminationContext();
 static void waitAll(std::vector<korali::Sample>& samples);
 static size_t waitAny(std::vector<korali::Sample>& samples);
};

extern korali::Sample* __current_sample;

}

#endif // __KORALI_SAMPLE_HPP_
