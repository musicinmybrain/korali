#include "sample/sample.hpp"
#include "engine/engine.hpp"
#include "problem/problem.hpp"
#include "solver/solver.hpp"

korali::Sample* korali::__current_sample;

void korali::Sample::threadCallWrapper()
{
 // This is not a thread-safe operation. For that to be the case, it would need
 // a mutex lock activated before setting __current_sample, and freed after reading it

 korali::Sample* currentSample = korali::__current_sample;
 currentSample->_isFinished = false;
 currentSample->_function(*currentSample);
 currentSample->_isFinished = true;
 currentSample->yield();
}

void korali::Sample::start(std::function<void(korali::Sample&)> func)
{
 _sampleThread = co_create(8192*sizeof(void*), korali::Sample::threadCallWrapper);
 _mainThread = co_active();
 _function = func;
 __current_sample = this;
 resume();
}

void korali::Sample::waitAll(std::vector<korali::Sample>& samples)
{
 bool isFinished = false;
 while (isFinished == false)
 {
  isFinished = true;
  for (size_t i = 0; i < samples.size(); i++)
   if (samples[i].isFinished() == false) isFinished = false;
 }

 for (size_t i = 0; i < samples.size(); i++) free(samples[i]._sampleThread);
}

void korali::Sample::yield()
{
 _k->_problem->_profileInfo.endWorkSegment();
 _k->_solver->_profileInfo.startWorkSegment();
 co_switch(_mainThread);
}

void korali::Sample::resume()
{
 _k->_solver->_profileInfo.endWorkSegment();
 _k->_problem->_profileInfo.startWorkSegment(_self->_sampleId);
 co_switch(_sampleThread);
}

bool korali::Sample::isFinished()
{
 if (_self->_isFinished == false) _self->resume();
 return _self->_isFinished;
}

void korali::Sample::wait()
{
 while(isFinished() == false);
 free(_self->_sampleThread);
 return;
}
