# G.1 - Building a Korali Application

Korali provides a range of optimization and uncertainty quantification tools. To use these tools, a user needs to create a *Korali Application*. This application serves as a nexus between the computational models (user-provided C++ objects, Python modules, or pre-compiled applications), and the Korali's main solver engine.

To build a Korali application in Python, you simply need to include the corresponding korali module and declare an instance of the Korali engine:

```python
#!/usr/bin/env python3
import korali
k = korali.initialize()
...
```

## Creating a Korali Application

A Korali application encapsulates the configuration necessary to run the Korali engine. In this section, we describe the steps required to create a Korali Application:

### Step 1) Define Problem

A Korali Problem describes the sampling space of the physical or real-world phenomenon to analyze. The number of variables defined by the user represents a dimension of the problem. Variables are created by simply adding their name to the problem configuration:

```python
# Example: Defining two variables
k["Variables"][0]["Name"] = "Thermal Conductivity"
k["Variables"][1]["Name"] = "Heat Source Position"
```

Variable definitions require additional parameters depending on which problem and solver types have been selected. These parameters are explained in detail at each solver/problem page.

Then, we need to tell Korali what information we would like to know about the problem. We call this 'Problem Type'. 

For example, the following type will sample the probability distribution of the variables: 

  ```python
   k["Problem"]["Type"] = "Sampling";
  ```

Below is a complete list of Korali-supported problem types:

<!--- Problems go here --->

### Step 2) Define Solver

The next step is to choose which solver algorithm should be used to obtain the results required by the problem. We call this 'Solver Type'. 

For example, the following solver will obtain the probability distribution using the TMCMC method: 

  ```python
   k["Solver"]["Type"] = "TMCMC";
  ```

Below is a complete list of solvers currently implemented in Korali:

<!--- Solvers go here --->

### Step 3) Define Conduit

The evaluation conduit module executes the computational model(s) for each sample and returns their raw results back to the solver. 

The choice of conduit depends on the design and requirements of the computational model. The simple (default) conduit is one that evaluates samples sequentially:

	```python
	 k["Conduit"]["Type"] = "Simple";
	```
Below is a complete list of conduits currently implemented in Korali:

<!--- Conduits go here --->

### Step 4) Define Model(s)

Next, the user needs to specify the computational model(s) that will evaluate the problem. Korali will run the model many times, given a *sample* -- a vector of stochastically-generated values for each variable defined in Step 1 --.

Each problem type have their specific model requirements. Nevertheless, below is a complete list of model-types currently implemented in Korali and their syntax:

<!--- Models go here --->

### Step 5) General Settings

The runtime Korali application can be easily configured by accessing the instance of the korali Engine. Here is a list of general settings that apply to any Korali app:

  ```python
      k["General"]["Verbosity"] = "Silent" # Do not produce console output.
  ```
  
Below is a complete list of general settings currently implemented in Korali:

<!--- General Settings go here --->

### Step 6) Running your Korali Application

A Python/C++ application can be run just like any other application, through a shell command:

```bash
> ./myApp myArguments
```
For distributed jobs, you can launch your Korali application with the SLURM/MPI launcher, specifying the number of cores, for example:

```bash
> srun -n 16 ./myApp myArguments
> mpirun -n 16 ./myApp myArguments
```

Once the Korali engine has started running, it will execute non-preemptively until a termination criterion is met. Each solver method exposes a configurable set of termination criteria.

After execution, Korali will automatically create a results folder where it will save the entire state of the engine (i.e., a *checkpoint*) after each generation. Users can perform several operations on these results:

- [Accessing Results](../results/#accessing-results)
- [Generate Plots](../results/#generate-plots)
- [Resume Execution](../results/#resume-execution)
